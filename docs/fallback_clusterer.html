<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>spectralcluster.fallback_clusterer API documentation</title>
<meta name="description" content="In some cases, we use a fallback clusterer instead of spectral â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>spectralcluster.fallback_clusterer</code></h1>
</header>
<section id="section-intro">
<p>In some cases, we use a fallback clusterer instead of spectral.</p>
<p>Spectral clustering exploits the global structure of the data. But there are
cases where spectral clustering does not work as well as some other simpler
clustering methods, such as when the number of embeddings is too small.</p>
<p>See this paper for more details:
Quan Wang, Yiling Huang, Han Lu, Guanlong Zhao, Ignacio Lopez Moreno,
"Highly Efficient Real-Time Streaming and Fully On-Device Speaker Diarization
with Multi-Stage Clustering", arXiv:2210.13690.
<a href="https://arxiv.org/abs/2210.13690">https://arxiv.org/abs/2210.13690</a></p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;In some cases, we use a fallback clusterer instead of spectral.

Spectral clustering exploits the global structure of the data. But there are
cases where spectral clustering does not work as well as some other simpler
clustering methods, such as when the number of embeddings is too small.

See this paper for more details:
Quan Wang, Yiling Huang, Han Lu, Guanlong Zhao, Ignacio Lopez Moreno,
&#34;Highly Efficient Real-Time Streaming and Fully On-Device Speaker Diarization
with Multi-Stage Clustering&#34;, arXiv:2210.13690.
https://arxiv.org/abs/2210.13690
&#34;&#34;&#34;

from dataclasses import dataclass
import enum
import numpy as np
from sklearn.cluster import AgglomerativeClustering
from sklearn.mixture import GaussianMixture
from spectralcluster import naive_clusterer
import typing


class SingleClusterCondition(enum.Enum):
  &#34;&#34;&#34;Which condition do we use for deciding single-vs-multi cluster(s).&#34;&#34;&#34;

  # Fit affinity values with GMM with 1-vs-2 component(s), and use
  # Bayesian Information Criterion (BIC) to decide whether there are
  # at least two clusters.
  # Note that this approach does not require additional parameters.
  AffinityGmmBic = enum.auto()

  # If all affinities are larger than threshold, there is only a single cluster.
  AllAffinity = enum.auto()

  # If all neighboring affinities are larger than threshold, there is only
  # a single cluster.
  NeighborAffinity = enum.auto()

  # If the standard deviation of all affinities is smaller than threshold,
  # there is only a single cluster.
  AffinityStd = enum.auto()

  # Use fallback clusterer to make the decision. If fallback clusterer
  # finds multiple clusters, continue with spectral clusterer.
  FallbackClusterer = enum.auto()


class FallbackClustererType(enum.Enum):
  &#34;&#34;&#34;Which fallback clusterer to use.&#34;&#34;&#34;

  # AgglomerativeClustering from scikit-learn.
  Agglomerative = enum.auto()

  # Naive clustering, as described in the paper &#34;Speaker diarization with LSTM&#34;.
  Naive = enum.auto()


@dataclass
class FallbackOptions:
  &#34;&#34;&#34;Options for fallback options.&#34;&#34;&#34;

  # We only run spectral clusterer if we have at least these many embeddings;
  # otherwise we run fallback clusterer.
  spectral_min_embeddings: int = 1

  # How do we decide single-vs-multi cluster(s).
  single_cluster_condition: SingleClusterCondition = (
      SingleClusterCondition.AffinityGmmBic)

  # Affinity threshold to decide whether there is only a single cluster.
  single_cluster_affinity_threshold: float = 0.75

  # When using AffinityGmmBic to make single-vs-multi cluster(s) decisions,
  # we only fit the GMM to the upper triangular matrix because the diagonal
  # and near-diagonal values might be very big. By default, we use a
  # value of 1 to only exclude diagonal values. But if embeddings are
  # extracted from overlapping sliding windows, this value could be larger
  # than 1.
  single_cluster_affinity_diagonal_offset: int = 1

  # Which fallback clusterer to use.
  fallback_clusterer_type: FallbackClustererType = (
      FallbackClustererType.Naive)

  # Threshold of agglomerative clustering.
  agglomerative_threshold: float = 0.5

  # Threshold for naive clusterer.
  naive_threshold: float = 0.5

  # Adaptation_threshold for naive clusterer.
  naive_adaptation_threshold: typing.Optional[float] = None


class FallbackClusterer:
  &#34;&#34;&#34;Fallback clusterer.

  The fallback clusterer is introduced in the multi-stage clustering paper
  (https://arxiv.org/abs/2210.13690). So far we simply use
  AgglomerativeClustering.
  &#34;&#34;&#34;

  def __init__(self, options: FallbackOptions):
    &#34;&#34;&#34;Initilization of the fallback clusterer.

    Args:
      options: an object of FallbackOptions
    &#34;&#34;&#34;
    self.options = options
    if options.fallback_clusterer_type == FallbackClustererType.Agglomerative:
      self.clusterer = AgglomerativeClustering(
          n_clusters=None,
          metric=&#34;cosine&#34;,
          linkage=&#34;average&#34;,
          distance_threshold=options.agglomerative_threshold)
    elif options.fallback_clusterer_type == FallbackClustererType.Naive:
      self.clusterer = naive_clusterer.NaiveClusterer(
          threshold=options.naive_threshold,
          adaptation_threshold=options.naive_adaptation_threshold)
    else:
      ValueError(&#34;Unsupported fallback_clusterer_type&#34;)

  def predict(self, embeddings: np.ndarray) -&gt; np.ndarray:
    return self.clusterer.fit_predict(embeddings)


def check_single_cluster(fallback_options: FallbackOptions,
                         embeddings: typing.Optional[np.ndarray],
                         affinity: np.ndarray) -&gt; bool:
  &#34;&#34;&#34;Check whether this is only a single cluster.

  This function is only called when min_clusters==1.

  Args:
    fallback_options: an object of FallbackOptions
    embeddings: numpy array of shape (n_samples, n_features)
    affinity: the affinity matrix of shape (n_samples, (n_samples)

  Returns:
    a boolean, where True means there is only a single cluster
  &#34;&#34;&#34;
  if (fallback_options.single_cluster_condition ==
      SingleClusterCondition.AllAffinity):
    if (affinity.min() &gt;
        fallback_options.single_cluster_affinity_threshold):
      return True
  elif (fallback_options.single_cluster_condition ==
        SingleClusterCondition.NeighborAffinity):
    neighbor_affinity = np.diag(affinity, k=1)
    if (neighbor_affinity.min() &gt;
        fallback_options.single_cluster_affinity_threshold):
      return True
  elif (fallback_options.single_cluster_condition ==
        SingleClusterCondition.AffinityStd):
    if (np.std(affinity) &lt;
        fallback_options.single_cluster_affinity_threshold):
      return True
  elif (fallback_options.single_cluster_condition ==
        SingleClusterCondition.AffinityGmmBic):
    # Compute upper triangular matrix values to exclude diagonal values.
    if (fallback_options.single_cluster_affinity_diagonal_offset &gt;=
        affinity.shape[0] - 1):
      raise ValueError(
          &#34;single_cluster_affinity_diagonal_offset must be significantly &#34;
          &#34;smaller than affinity matrix dimension&#34;)
    upper_indices = np.triu_indices(
        affinity.shape[0],
        fallback_options.single_cluster_affinity_diagonal_offset)
    affinity_values = np.expand_dims(affinity[upper_indices], 1)

    # Fit GMM and compare BIC.
    gmm1 = GaussianMixture(n_components=1)
    gmm2 = GaussianMixture(n_components=2)
    gmm1.fit(affinity_values)
    gmm2.fit(affinity_values)
    bic1 = gmm1.bic(affinity_values)
    bic2 = gmm2.bic(affinity_values)
    return bic1 &lt; bic2
  elif (fallback_options.single_cluster_condition ==
        SingleClusterCondition.FallbackClusterer):
    temp_clusterer = FallbackClusterer(fallback_options)
    temp_labels = temp_clusterer.predict(embeddings)
    if np.unique(temp_labels).size == 1:
      return True
  else:
    raise TypeError(&#34;Unsupported single_cluster_condition&#34;)
  return False</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="spectralcluster.fallback_clusterer.check_single_cluster"><code class="name flex">
<span>def <span class="ident">check_single_cluster</span></span>(<span>fallback_options:Â <a title="spectralcluster.fallback_clusterer.FallbackOptions" href="#spectralcluster.fallback_clusterer.FallbackOptions">FallbackOptions</a>, embeddings:Â Optional[numpy.ndarray], affinity:Â numpy.ndarray) â€‘>Â bool</span>
</code></dt>
<dd>
<div class="desc"><p>Check whether this is only a single cluster.</p>
<p>This function is only called when min_clusters==1.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>fallback_options</code></strong></dt>
<dd>an object of FallbackOptions</dd>
<dt><strong><code>embeddings</code></strong></dt>
<dd>numpy array of shape (n_samples, n_features)</dd>
<dt><strong><code>affinity</code></strong></dt>
<dd>the affinity matrix of shape (n_samples, (n_samples)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>a boolean, where True means there is only a single cluster</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_single_cluster(fallback_options: FallbackOptions,
                         embeddings: typing.Optional[np.ndarray],
                         affinity: np.ndarray) -&gt; bool:
  &#34;&#34;&#34;Check whether this is only a single cluster.

  This function is only called when min_clusters==1.

  Args:
    fallback_options: an object of FallbackOptions
    embeddings: numpy array of shape (n_samples, n_features)
    affinity: the affinity matrix of shape (n_samples, (n_samples)

  Returns:
    a boolean, where True means there is only a single cluster
  &#34;&#34;&#34;
  if (fallback_options.single_cluster_condition ==
      SingleClusterCondition.AllAffinity):
    if (affinity.min() &gt;
        fallback_options.single_cluster_affinity_threshold):
      return True
  elif (fallback_options.single_cluster_condition ==
        SingleClusterCondition.NeighborAffinity):
    neighbor_affinity = np.diag(affinity, k=1)
    if (neighbor_affinity.min() &gt;
        fallback_options.single_cluster_affinity_threshold):
      return True
  elif (fallback_options.single_cluster_condition ==
        SingleClusterCondition.AffinityStd):
    if (np.std(affinity) &lt;
        fallback_options.single_cluster_affinity_threshold):
      return True
  elif (fallback_options.single_cluster_condition ==
        SingleClusterCondition.AffinityGmmBic):
    # Compute upper triangular matrix values to exclude diagonal values.
    if (fallback_options.single_cluster_affinity_diagonal_offset &gt;=
        affinity.shape[0] - 1):
      raise ValueError(
          &#34;single_cluster_affinity_diagonal_offset must be significantly &#34;
          &#34;smaller than affinity matrix dimension&#34;)
    upper_indices = np.triu_indices(
        affinity.shape[0],
        fallback_options.single_cluster_affinity_diagonal_offset)
    affinity_values = np.expand_dims(affinity[upper_indices], 1)

    # Fit GMM and compare BIC.
    gmm1 = GaussianMixture(n_components=1)
    gmm2 = GaussianMixture(n_components=2)
    gmm1.fit(affinity_values)
    gmm2.fit(affinity_values)
    bic1 = gmm1.bic(affinity_values)
    bic2 = gmm2.bic(affinity_values)
    return bic1 &lt; bic2
  elif (fallback_options.single_cluster_condition ==
        SingleClusterCondition.FallbackClusterer):
    temp_clusterer = FallbackClusterer(fallback_options)
    temp_labels = temp_clusterer.predict(embeddings)
    if np.unique(temp_labels).size == 1:
      return True
  else:
    raise TypeError(&#34;Unsupported single_cluster_condition&#34;)
  return False</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="spectralcluster.fallback_clusterer.FallbackClusterer"><code class="flex name class">
<span>class <span class="ident">FallbackClusterer</span></span>
<span>(</span><span>options:Â <a title="spectralcluster.fallback_clusterer.FallbackOptions" href="#spectralcluster.fallback_clusterer.FallbackOptions">FallbackOptions</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Fallback clusterer.</p>
<p>The fallback clusterer is introduced in the multi-stage clustering paper
(<a href="https://arxiv.org/abs/2210.13690">https://arxiv.org/abs/2210.13690</a>). So far we simply use
AgglomerativeClustering.</p>
<p>Initilization of the fallback clusterer.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>options</code></strong></dt>
<dd>an object of FallbackOptions</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FallbackClusterer:
  &#34;&#34;&#34;Fallback clusterer.

  The fallback clusterer is introduced in the multi-stage clustering paper
  (https://arxiv.org/abs/2210.13690). So far we simply use
  AgglomerativeClustering.
  &#34;&#34;&#34;

  def __init__(self, options: FallbackOptions):
    &#34;&#34;&#34;Initilization of the fallback clusterer.

    Args:
      options: an object of FallbackOptions
    &#34;&#34;&#34;
    self.options = options
    if options.fallback_clusterer_type == FallbackClustererType.Agglomerative:
      self.clusterer = AgglomerativeClustering(
          n_clusters=None,
          metric=&#34;cosine&#34;,
          linkage=&#34;average&#34;,
          distance_threshold=options.agglomerative_threshold)
    elif options.fallback_clusterer_type == FallbackClustererType.Naive:
      self.clusterer = naive_clusterer.NaiveClusterer(
          threshold=options.naive_threshold,
          adaptation_threshold=options.naive_adaptation_threshold)
    else:
      ValueError(&#34;Unsupported fallback_clusterer_type&#34;)

  def predict(self, embeddings: np.ndarray) -&gt; np.ndarray:
    return self.clusterer.fit_predict(embeddings)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="spectralcluster.fallback_clusterer.FallbackClusterer.predict"><code class="name flex">
<span>def <span class="ident">predict</span></span>(<span>self, embeddings:Â numpy.ndarray) â€‘>Â numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def predict(self, embeddings: np.ndarray) -&gt; np.ndarray:
  return self.clusterer.fit_predict(embeddings)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="spectralcluster.fallback_clusterer.FallbackClustererType"><code class="flex name class">
<span>class <span class="ident">FallbackClustererType</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Which fallback clusterer to use.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FallbackClustererType(enum.Enum):
  &#34;&#34;&#34;Which fallback clusterer to use.&#34;&#34;&#34;

  # AgglomerativeClustering from scikit-learn.
  Agglomerative = enum.auto()

  # Naive clustering, as described in the paper &#34;Speaker diarization with LSTM&#34;.
  Naive = enum.auto()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="spectralcluster.fallback_clusterer.FallbackClustererType.Agglomerative"><code class="name">var <span class="ident">Agglomerative</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spectralcluster.fallback_clusterer.FallbackClustererType.Naive"><code class="name">var <span class="ident">Naive</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="spectralcluster.fallback_clusterer.FallbackOptions"><code class="flex name class">
<span>class <span class="ident">FallbackOptions</span></span>
<span>(</span><span>spectral_min_embeddings:Â intÂ =Â 1, single_cluster_condition:Â <a title="spectralcluster.fallback_clusterer.SingleClusterCondition" href="#spectralcluster.fallback_clusterer.SingleClusterCondition">SingleClusterCondition</a>Â =Â SingleClusterCondition.AffinityGmmBic, single_cluster_affinity_threshold:Â floatÂ =Â 0.75, single_cluster_affinity_diagonal_offset:Â intÂ =Â 1, fallback_clusterer_type:Â <a title="spectralcluster.fallback_clusterer.FallbackClustererType" href="#spectralcluster.fallback_clusterer.FallbackClustererType">FallbackClustererType</a>Â =Â FallbackClustererType.Naive, agglomerative_threshold:Â floatÂ =Â 0.5, naive_threshold:Â floatÂ =Â 0.5, naive_adaptation_threshold:Â Optional[float]Â =Â None)</span>
</code></dt>
<dd>
<div class="desc"><p>Options for fallback options.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class FallbackOptions:
  &#34;&#34;&#34;Options for fallback options.&#34;&#34;&#34;

  # We only run spectral clusterer if we have at least these many embeddings;
  # otherwise we run fallback clusterer.
  spectral_min_embeddings: int = 1

  # How do we decide single-vs-multi cluster(s).
  single_cluster_condition: SingleClusterCondition = (
      SingleClusterCondition.AffinityGmmBic)

  # Affinity threshold to decide whether there is only a single cluster.
  single_cluster_affinity_threshold: float = 0.75

  # When using AffinityGmmBic to make single-vs-multi cluster(s) decisions,
  # we only fit the GMM to the upper triangular matrix because the diagonal
  # and near-diagonal values might be very big. By default, we use a
  # value of 1 to only exclude diagonal values. But if embeddings are
  # extracted from overlapping sliding windows, this value could be larger
  # than 1.
  single_cluster_affinity_diagonal_offset: int = 1

  # Which fallback clusterer to use.
  fallback_clusterer_type: FallbackClustererType = (
      FallbackClustererType.Naive)

  # Threshold of agglomerative clustering.
  agglomerative_threshold: float = 0.5

  # Threshold for naive clusterer.
  naive_threshold: float = 0.5

  # Adaptation_threshold for naive clusterer.
  naive_adaptation_threshold: typing.Optional[float] = None</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="spectralcluster.fallback_clusterer.FallbackOptions.agglomerative_threshold"><code class="name">var <span class="ident">agglomerative_threshold</span> :Â float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spectralcluster.fallback_clusterer.FallbackOptions.fallback_clusterer_type"><code class="name">var <span class="ident">fallback_clusterer_type</span> :Â <a title="spectralcluster.fallback_clusterer.FallbackClustererType" href="#spectralcluster.fallback_clusterer.FallbackClustererType">FallbackClustererType</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spectralcluster.fallback_clusterer.FallbackOptions.naive_adaptation_threshold"><code class="name">var <span class="ident">naive_adaptation_threshold</span> :Â Optional[float]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spectralcluster.fallback_clusterer.FallbackOptions.naive_threshold"><code class="name">var <span class="ident">naive_threshold</span> :Â float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spectralcluster.fallback_clusterer.FallbackOptions.single_cluster_affinity_diagonal_offset"><code class="name">var <span class="ident">single_cluster_affinity_diagonal_offset</span> :Â int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spectralcluster.fallback_clusterer.FallbackOptions.single_cluster_affinity_threshold"><code class="name">var <span class="ident">single_cluster_affinity_threshold</span> :Â float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spectralcluster.fallback_clusterer.FallbackOptions.single_cluster_condition"><code class="name">var <span class="ident">single_cluster_condition</span> :Â <a title="spectralcluster.fallback_clusterer.SingleClusterCondition" href="#spectralcluster.fallback_clusterer.SingleClusterCondition">SingleClusterCondition</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spectralcluster.fallback_clusterer.FallbackOptions.spectral_min_embeddings"><code class="name">var <span class="ident">spectral_min_embeddings</span> :Â int</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="spectralcluster.fallback_clusterer.SingleClusterCondition"><code class="flex name class">
<span>class <span class="ident">SingleClusterCondition</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Which condition do we use for deciding single-vs-multi cluster(s).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SingleClusterCondition(enum.Enum):
  &#34;&#34;&#34;Which condition do we use for deciding single-vs-multi cluster(s).&#34;&#34;&#34;

  # Fit affinity values with GMM with 1-vs-2 component(s), and use
  # Bayesian Information Criterion (BIC) to decide whether there are
  # at least two clusters.
  # Note that this approach does not require additional parameters.
  AffinityGmmBic = enum.auto()

  # If all affinities are larger than threshold, there is only a single cluster.
  AllAffinity = enum.auto()

  # If all neighboring affinities are larger than threshold, there is only
  # a single cluster.
  NeighborAffinity = enum.auto()

  # If the standard deviation of all affinities is smaller than threshold,
  # there is only a single cluster.
  AffinityStd = enum.auto()

  # Use fallback clusterer to make the decision. If fallback clusterer
  # finds multiple clusters, continue with spectral clusterer.
  FallbackClusterer = enum.auto()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="spectralcluster.fallback_clusterer.SingleClusterCondition.AffinityGmmBic"><code class="name">var <span class="ident">AffinityGmmBic</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spectralcluster.fallback_clusterer.SingleClusterCondition.AffinityStd"><code class="name">var <span class="ident">AffinityStd</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spectralcluster.fallback_clusterer.SingleClusterCondition.AllAffinity"><code class="name">var <span class="ident">AllAffinity</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spectralcluster.fallback_clusterer.SingleClusterCondition.FallbackClusterer"><code class="name">var <span class="ident">FallbackClusterer</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="spectralcluster.fallback_clusterer.SingleClusterCondition.NeighborAffinity"><code class="name">var <span class="ident">NeighborAffinity</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="spectralcluster" href="index.html">spectralcluster</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="spectralcluster.fallback_clusterer.check_single_cluster" href="#spectralcluster.fallback_clusterer.check_single_cluster">check_single_cluster</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="spectralcluster.fallback_clusterer.FallbackClusterer" href="#spectralcluster.fallback_clusterer.FallbackClusterer">FallbackClusterer</a></code></h4>
<ul class="">
<li><code><a title="spectralcluster.fallback_clusterer.FallbackClusterer.predict" href="#spectralcluster.fallback_clusterer.FallbackClusterer.predict">predict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spectralcluster.fallback_clusterer.FallbackClustererType" href="#spectralcluster.fallback_clusterer.FallbackClustererType">FallbackClustererType</a></code></h4>
<ul class="">
<li><code><a title="spectralcluster.fallback_clusterer.FallbackClustererType.Agglomerative" href="#spectralcluster.fallback_clusterer.FallbackClustererType.Agglomerative">Agglomerative</a></code></li>
<li><code><a title="spectralcluster.fallback_clusterer.FallbackClustererType.Naive" href="#spectralcluster.fallback_clusterer.FallbackClustererType.Naive">Naive</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spectralcluster.fallback_clusterer.FallbackOptions" href="#spectralcluster.fallback_clusterer.FallbackOptions">FallbackOptions</a></code></h4>
<ul class="">
<li><code><a title="spectralcluster.fallback_clusterer.FallbackOptions.agglomerative_threshold" href="#spectralcluster.fallback_clusterer.FallbackOptions.agglomerative_threshold">agglomerative_threshold</a></code></li>
<li><code><a title="spectralcluster.fallback_clusterer.FallbackOptions.fallback_clusterer_type" href="#spectralcluster.fallback_clusterer.FallbackOptions.fallback_clusterer_type">fallback_clusterer_type</a></code></li>
<li><code><a title="spectralcluster.fallback_clusterer.FallbackOptions.naive_adaptation_threshold" href="#spectralcluster.fallback_clusterer.FallbackOptions.naive_adaptation_threshold">naive_adaptation_threshold</a></code></li>
<li><code><a title="spectralcluster.fallback_clusterer.FallbackOptions.naive_threshold" href="#spectralcluster.fallback_clusterer.FallbackOptions.naive_threshold">naive_threshold</a></code></li>
<li><code><a title="spectralcluster.fallback_clusterer.FallbackOptions.single_cluster_affinity_diagonal_offset" href="#spectralcluster.fallback_clusterer.FallbackOptions.single_cluster_affinity_diagonal_offset">single_cluster_affinity_diagonal_offset</a></code></li>
<li><code><a title="spectralcluster.fallback_clusterer.FallbackOptions.single_cluster_affinity_threshold" href="#spectralcluster.fallback_clusterer.FallbackOptions.single_cluster_affinity_threshold">single_cluster_affinity_threshold</a></code></li>
<li><code><a title="spectralcluster.fallback_clusterer.FallbackOptions.single_cluster_condition" href="#spectralcluster.fallback_clusterer.FallbackOptions.single_cluster_condition">single_cluster_condition</a></code></li>
<li><code><a title="spectralcluster.fallback_clusterer.FallbackOptions.spectral_min_embeddings" href="#spectralcluster.fallback_clusterer.FallbackOptions.spectral_min_embeddings">spectral_min_embeddings</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="spectralcluster.fallback_clusterer.SingleClusterCondition" href="#spectralcluster.fallback_clusterer.SingleClusterCondition">SingleClusterCondition</a></code></h4>
<ul class="">
<li><code><a title="spectralcluster.fallback_clusterer.SingleClusterCondition.AffinityGmmBic" href="#spectralcluster.fallback_clusterer.SingleClusterCondition.AffinityGmmBic">AffinityGmmBic</a></code></li>
<li><code><a title="spectralcluster.fallback_clusterer.SingleClusterCondition.AffinityStd" href="#spectralcluster.fallback_clusterer.SingleClusterCondition.AffinityStd">AffinityStd</a></code></li>
<li><code><a title="spectralcluster.fallback_clusterer.SingleClusterCondition.AllAffinity" href="#spectralcluster.fallback_clusterer.SingleClusterCondition.AllAffinity">AllAffinity</a></code></li>
<li><code><a title="spectralcluster.fallback_clusterer.SingleClusterCondition.FallbackClusterer" href="#spectralcluster.fallback_clusterer.SingleClusterCondition.FallbackClusterer">FallbackClusterer</a></code></li>
<li><code><a title="spectralcluster.fallback_clusterer.SingleClusterCondition.NeighborAffinity" href="#spectralcluster.fallback_clusterer.SingleClusterCondition.NeighborAffinity">NeighborAffinity</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>