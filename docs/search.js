window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "spectralcluster", "modulename": "spectralcluster", "kind": "module", "doc": "<p>__init__ file.</p>\n"}, {"fullname": "spectralcluster.AutoTune", "modulename": "spectralcluster", "qualname": "AutoTune", "kind": "class", "doc": "<p>AutoTune Class.</p>\n\n<p>This auto-tuning method is implemented based on this paper:\nPark, Tae Jin, et al. \"Auto-tuning spectral clustering for speaker\ndiarization using normalized maximum eigengap.\" IEEE Signal Processing Letter\n2019.</p>\n"}, {"fullname": "spectralcluster.AutoTune.__init__", "modulename": "spectralcluster", "qualname": "AutoTune.__init__", "kind": "function", "doc": "<p>Initialization of the autotune arguments.</p>\n\n<p>Args:\n  p_percentile_min: minimum value of p_percentile\n  p_percentile_max: maximum value of p_percentile\n  init_search_step: initial search step size for auto-tuning\n  search_level: hierarchical search level for auto-tuning\n  proxy: which proxy to minimize for auto-tuning</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">p_percentile_min</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.6</span>,</span><span class=\"param\">\t<span class=\"n\">p_percentile_max</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.95</span>,</span><span class=\"param\">\t<span class=\"n\">init_search_step</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.01</span>,</span><span class=\"param\">\t<span class=\"n\">search_level</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">proxy</span><span class=\"p\">:</span> <span class=\"n\">spectralcluster</span><span class=\"o\">.</span><span class=\"n\">autotune</span><span class=\"o\">.</span><span class=\"n\">AutoTuneProxy</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">AutoTuneProxy</span><span class=\"o\">.</span><span class=\"n\">PercentileSqrtOverNME</span><span class=\"p\">:</span> <span class=\"mi\">2</span><span class=\"o\">&gt;</span></span>)</span>"}, {"fullname": "spectralcluster.AutoTune.p_percentile_min", "modulename": "spectralcluster", "qualname": "AutoTune.p_percentile_min", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "spectralcluster.AutoTune.p_percentile_max", "modulename": "spectralcluster", "qualname": "AutoTune.p_percentile_max", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "spectralcluster.AutoTune.search_step", "modulename": "spectralcluster", "qualname": "AutoTune.search_step", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "spectralcluster.AutoTune.search_level", "modulename": "spectralcluster", "qualname": "AutoTune.search_level", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "spectralcluster.AutoTune.proxy", "modulename": "spectralcluster", "qualname": "AutoTune.proxy", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "spectralcluster.AutoTune.get_percentile_range", "modulename": "spectralcluster", "qualname": "AutoTune.get_percentile_range", "kind": "function", "doc": "<p>Get the current percentile search range.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "spectralcluster.AutoTune.update_percentile_range", "modulename": "spectralcluster", "qualname": "AutoTune.update_percentile_range", "kind": "function", "doc": "<p>Update the percentile search range.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">p_percentile_min</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">p_percentile_max</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">search_step</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "spectralcluster.AutoTune.tune", "modulename": "spectralcluster", "qualname": "AutoTune.tune", "kind": "function", "doc": "<p>Tune the hyper-parameter p_percentile.</p>\n\n<p>Use a proxy ratio of DER to tune the hyper-parameter p_percentile. It also\nperforms some side work to do affinity refinement, eigen decomposition, and\nestimate the number of clusters.</p>\n\n<p>Args:\n  p_percentile_to_ratio: a callable to compute the <code>ratio</code> given a\n    <code>p_percentile</code> value</p>\n\n<p>Returns:\n  eigenvectors: sorted eigenvectors. numpy array of shape\n  (n_samples, n_samples)\n  n_clusters: number of clusters as an integer\n  best_p_percentile: p_percentile value that minimizes the ratio</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">p_percentile_to_ratio</span><span class=\"p\">:</span> <span class=\"n\">Callable</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "spectralcluster.AutoTuneProxy", "modulename": "spectralcluster", "qualname": "AutoTuneProxy", "kind": "class", "doc": "<p>What proxy to use as the auto-tuning target.</p>\n", "bases": "enum.Enum"}, {"fullname": "spectralcluster.AutoTuneProxy.PercentileOverNME", "modulename": "spectralcluster", "qualname": "AutoTuneProxy.PercentileOverNME", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;AutoTuneProxy.PercentileOverNME: 1&gt;"}, {"fullname": "spectralcluster.AutoTuneProxy.PercentileSqrtOverNME", "modulename": "spectralcluster", "qualname": "AutoTuneProxy.PercentileSqrtOverNME", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;AutoTuneProxy.PercentileSqrtOverNME: 2&gt;"}, {"fullname": "spectralcluster.ConstraintOptions", "modulename": "spectralcluster", "qualname": "ConstraintOptions", "kind": "class", "doc": "<p>Constraint options for constrained clustering methods.</p>\n"}, {"fullname": "spectralcluster.ConstraintOptions.__init__", "modulename": "spectralcluster", "qualname": "ConstraintOptions.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">constraint_name</span><span class=\"p\">:</span> <span class=\"n\">spectralcluster</span><span class=\"o\">.</span><span class=\"n\">constraint</span><span class=\"o\">.</span><span class=\"n\">ConstraintName</span>,</span><span class=\"param\">\t<span class=\"n\">apply_before_refinement</span><span class=\"p\">:</span> <span class=\"nb\">bool</span>,</span><span class=\"param\">\t<span class=\"n\">integration_type</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">spectralcluster</span><span class=\"o\">.</span><span class=\"n\">constraint</span><span class=\"o\">.</span><span class=\"n\">IntegrationType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">constraint_propagation_alpha</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.6</span></span>)</span>"}, {"fullname": "spectralcluster.ConstraintOptions.constraint_name", "modulename": "spectralcluster", "qualname": "ConstraintOptions.constraint_name", "kind": "variable", "doc": "<p></p>\n", "annotation": ": spectralcluster.constraint.ConstraintName"}, {"fullname": "spectralcluster.ConstraintOptions.apply_before_refinement", "modulename": "spectralcluster", "qualname": "ConstraintOptions.apply_before_refinement", "kind": "variable", "doc": "<p></p>\n", "annotation": ": bool"}, {"fullname": "spectralcluster.ConstraintOptions.integration_type", "modulename": "spectralcluster", "qualname": "ConstraintOptions.integration_type", "kind": "variable", "doc": "<p></p>\n", "annotation": ": Optional[spectralcluster.constraint.IntegrationType]", "default_value": "None"}, {"fullname": "spectralcluster.ConstraintOptions.constraint_propagation_alpha", "modulename": "spectralcluster", "qualname": "ConstraintOptions.constraint_propagation_alpha", "kind": "variable", "doc": "<p></p>\n", "annotation": ": float", "default_value": "0.6"}, {"fullname": "spectralcluster.ConstraintName", "modulename": "spectralcluster", "qualname": "ConstraintName", "kind": "class", "doc": "<p>The names of constrained operations.</p>\n", "bases": "enum.Enum"}, {"fullname": "spectralcluster.ConstraintName.AffinityIntegration", "modulename": "spectralcluster", "qualname": "ConstraintName.AffinityIntegration", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;ConstraintName.AffinityIntegration: 1&gt;"}, {"fullname": "spectralcluster.ConstraintName.ConstraintPropagation", "modulename": "spectralcluster", "qualname": "ConstraintName.ConstraintPropagation", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;ConstraintName.ConstraintPropagation: 2&gt;"}, {"fullname": "spectralcluster.ConstraintMatrix", "modulename": "spectralcluster", "qualname": "ConstraintMatrix", "kind": "class", "doc": "<p>Constraint Matrix class.</p>\n"}, {"fullname": "spectralcluster.ConstraintMatrix.__init__", "modulename": "spectralcluster", "qualname": "ConstraintMatrix.__init__", "kind": "function", "doc": "<p>Initialization of the constraint matrix arguments.</p>\n\n<p>Args:\n  speaker_turn_scores: A list of speaker turn confidence scores. All score\n    values are larger or equal to 0. If score is 0, there is no speaker\n    turn. speaker_turn_scores[i+1] means the speaker turn confidence score\n    between turn i+1 and turn i. The first score speaker_turn_scores[0] is\n    not used.\n  threshold: A threshold value for the speaker turn confidence score.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">speaker_turn_scores</span><span class=\"p\">:</span> <span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span>, </span><span class=\"param\"><span class=\"n\">threshold</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mi\">1</span></span>)</span>"}, {"fullname": "spectralcluster.ConstraintMatrix.speaker_turn_scores", "modulename": "spectralcluster", "qualname": "ConstraintMatrix.speaker_turn_scores", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "spectralcluster.ConstraintMatrix.threshold", "modulename": "spectralcluster", "qualname": "ConstraintMatrix.threshold", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "spectralcluster.ConstraintMatrix.compute_diagonals", "modulename": "spectralcluster", "qualname": "ConstraintMatrix.compute_diagonals", "kind": "function", "doc": "<p>Compute diagonal constraint matrix.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "spectralcluster.IntegrationType", "modulename": "spectralcluster", "qualname": "IntegrationType", "kind": "class", "doc": "<p>The integration types for the Affinity Integration method.</p>\n", "bases": "enum.Enum"}, {"fullname": "spectralcluster.IntegrationType.Max", "modulename": "spectralcluster", "qualname": "IntegrationType.Max", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;IntegrationType.Max: 1&gt;"}, {"fullname": "spectralcluster.IntegrationType.Average", "modulename": "spectralcluster", "qualname": "IntegrationType.Average", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;IntegrationType.Average: 2&gt;"}, {"fullname": "spectralcluster.FallbackOptions", "modulename": "spectralcluster", "qualname": "FallbackOptions", "kind": "class", "doc": "<p>Options for fallback options.</p>\n"}, {"fullname": "spectralcluster.FallbackOptions.__init__", "modulename": "spectralcluster", "qualname": "FallbackOptions.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">spectral_min_embeddings</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">single_cluster_condition</span><span class=\"p\">:</span> <span class=\"n\">spectralcluster</span><span class=\"o\">.</span><span class=\"n\">fallback_clusterer</span><span class=\"o\">.</span><span class=\"n\">SingleClusterCondition</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">SingleClusterCondition</span><span class=\"o\">.</span><span class=\"n\">AffinityGmmBic</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">single_cluster_affinity_threshold</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.75</span>,</span><span class=\"param\">\t<span class=\"n\">single_cluster_affinity_diagonal_offset</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">fallback_clusterer_type</span><span class=\"p\">:</span> <span class=\"n\">spectralcluster</span><span class=\"o\">.</span><span class=\"n\">fallback_clusterer</span><span class=\"o\">.</span><span class=\"n\">FallbackClustererType</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">FallbackClustererType</span><span class=\"o\">.</span><span class=\"n\">Naive</span><span class=\"p\">:</span> <span class=\"mi\">2</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">agglomerative_threshold</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.5</span>,</span><span class=\"param\">\t<span class=\"n\">naive_threshold</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.5</span>,</span><span class=\"param\">\t<span class=\"n\">naive_adaptation_threshold</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span>)</span>"}, {"fullname": "spectralcluster.FallbackOptions.spectral_min_embeddings", "modulename": "spectralcluster", "qualname": "FallbackOptions.spectral_min_embeddings", "kind": "variable", "doc": "<p></p>\n", "annotation": ": int", "default_value": "1"}, {"fullname": "spectralcluster.FallbackOptions.single_cluster_condition", "modulename": "spectralcluster", "qualname": "FallbackOptions.single_cluster_condition", "kind": "variable", "doc": "<p></p>\n", "annotation": ": spectralcluster.fallback_clusterer.SingleClusterCondition", "default_value": "&lt;SingleClusterCondition.AffinityGmmBic: 1&gt;"}, {"fullname": "spectralcluster.FallbackOptions.single_cluster_affinity_threshold", "modulename": "spectralcluster", "qualname": "FallbackOptions.single_cluster_affinity_threshold", "kind": "variable", "doc": "<p></p>\n", "annotation": ": float", "default_value": "0.75"}, {"fullname": "spectralcluster.FallbackOptions.single_cluster_affinity_diagonal_offset", "modulename": "spectralcluster", "qualname": "FallbackOptions.single_cluster_affinity_diagonal_offset", "kind": "variable", "doc": "<p></p>\n", "annotation": ": int", "default_value": "1"}, {"fullname": "spectralcluster.FallbackOptions.fallback_clusterer_type", "modulename": "spectralcluster", "qualname": "FallbackOptions.fallback_clusterer_type", "kind": "variable", "doc": "<p></p>\n", "annotation": ": spectralcluster.fallback_clusterer.FallbackClustererType", "default_value": "&lt;FallbackClustererType.Naive: 2&gt;"}, {"fullname": "spectralcluster.FallbackOptions.agglomerative_threshold", "modulename": "spectralcluster", "qualname": "FallbackOptions.agglomerative_threshold", "kind": "variable", "doc": "<p></p>\n", "annotation": ": float", "default_value": "0.5"}, {"fullname": "spectralcluster.FallbackOptions.naive_threshold", "modulename": "spectralcluster", "qualname": "FallbackOptions.naive_threshold", "kind": "variable", "doc": "<p></p>\n", "annotation": ": float", "default_value": "0.5"}, {"fullname": "spectralcluster.FallbackOptions.naive_adaptation_threshold", "modulename": "spectralcluster", "qualname": "FallbackOptions.naive_adaptation_threshold", "kind": "variable", "doc": "<p></p>\n", "annotation": ": Optional[float]", "default_value": "None"}, {"fullname": "spectralcluster.SingleClusterCondition", "modulename": "spectralcluster", "qualname": "SingleClusterCondition", "kind": "class", "doc": "<p>Which condition do we use for deciding single-vs-multi cluster(s).</p>\n", "bases": "enum.Enum"}, {"fullname": "spectralcluster.SingleClusterCondition.AffinityGmmBic", "modulename": "spectralcluster", "qualname": "SingleClusterCondition.AffinityGmmBic", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;SingleClusterCondition.AffinityGmmBic: 1&gt;"}, {"fullname": "spectralcluster.SingleClusterCondition.AllAffinity", "modulename": "spectralcluster", "qualname": "SingleClusterCondition.AllAffinity", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;SingleClusterCondition.AllAffinity: 2&gt;"}, {"fullname": "spectralcluster.SingleClusterCondition.NeighborAffinity", "modulename": "spectralcluster", "qualname": "SingleClusterCondition.NeighborAffinity", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;SingleClusterCondition.NeighborAffinity: 3&gt;"}, {"fullname": "spectralcluster.SingleClusterCondition.AffinityStd", "modulename": "spectralcluster", "qualname": "SingleClusterCondition.AffinityStd", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;SingleClusterCondition.AffinityStd: 4&gt;"}, {"fullname": "spectralcluster.SingleClusterCondition.FallbackClusterer", "modulename": "spectralcluster", "qualname": "SingleClusterCondition.FallbackClusterer", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;SingleClusterCondition.FallbackClusterer: 5&gt;"}, {"fullname": "spectralcluster.FallbackClustererType", "modulename": "spectralcluster", "qualname": "FallbackClustererType", "kind": "class", "doc": "<p>Which fallback clusterer to use.</p>\n", "bases": "enum.Enum"}, {"fullname": "spectralcluster.FallbackClustererType.Agglomerative", "modulename": "spectralcluster", "qualname": "FallbackClustererType.Agglomerative", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;FallbackClustererType.Agglomerative: 1&gt;"}, {"fullname": "spectralcluster.FallbackClustererType.Naive", "modulename": "spectralcluster", "qualname": "FallbackClustererType.Naive", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;FallbackClustererType.Naive: 2&gt;"}, {"fullname": "spectralcluster.LaplacianType", "modulename": "spectralcluster", "qualname": "LaplacianType", "kind": "class", "doc": "<p>Different types of Laplacian matrix.</p>\n", "bases": "enum.Enum"}, {"fullname": "spectralcluster.LaplacianType.Affinity", "modulename": "spectralcluster", "qualname": "LaplacianType.Affinity", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;LaplacianType.Affinity: 1&gt;"}, {"fullname": "spectralcluster.LaplacianType.Unnormalized", "modulename": "spectralcluster", "qualname": "LaplacianType.Unnormalized", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;LaplacianType.Unnormalized: 2&gt;"}, {"fullname": "spectralcluster.LaplacianType.RandomWalk", "modulename": "spectralcluster", "qualname": "LaplacianType.RandomWalk", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;LaplacianType.RandomWalk: 3&gt;"}, {"fullname": "spectralcluster.LaplacianType.GraphCut", "modulename": "spectralcluster", "qualname": "LaplacianType.GraphCut", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;LaplacianType.GraphCut: 4&gt;"}, {"fullname": "spectralcluster.Deflicker", "modulename": "spectralcluster", "qualname": "Deflicker", "kind": "class", "doc": "<p>Method to deflicker the streaming output labels.</p>\n", "bases": "enum.Enum"}, {"fullname": "spectralcluster.Deflicker.NoDeflicker", "modulename": "spectralcluster", "qualname": "Deflicker.NoDeflicker", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;Deflicker.NoDeflicker: 1&gt;"}, {"fullname": "spectralcluster.Deflicker.OrderBased", "modulename": "spectralcluster", "qualname": "Deflicker.OrderBased", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;Deflicker.OrderBased: 2&gt;"}, {"fullname": "spectralcluster.Deflicker.Hungarian", "modulename": "spectralcluster", "qualname": "Deflicker.Hungarian", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;Deflicker.Hungarian: 3&gt;"}, {"fullname": "spectralcluster.MultiStageClusterer", "modulename": "spectralcluster", "qualname": "MultiStageClusterer", "kind": "class", "doc": "<p>Multi-stage clustering class.</p>\n"}, {"fullname": "spectralcluster.MultiStageClusterer.__init__", "modulename": "spectralcluster", "qualname": "MultiStageClusterer.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">main_clusterer</span><span class=\"p\">:</span> <span class=\"n\">spectralcluster</span><span class=\"o\">.</span><span class=\"n\">spectral_clusterer</span><span class=\"o\">.</span><span class=\"n\">SpectralClusterer</span>,</span><span class=\"param\">\t<span class=\"n\">fallback_threshold</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.5</span>,</span><span class=\"param\">\t<span class=\"n\">L</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">50</span>,</span><span class=\"param\">\t<span class=\"n\">U1</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">100</span>,</span><span class=\"param\">\t<span class=\"n\">U2</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">600</span>,</span><span class=\"param\">\t<span class=\"n\">deflicker</span><span class=\"p\">:</span> <span class=\"n\">spectralcluster</span><span class=\"o\">.</span><span class=\"n\">multi_stage_clusterer</span><span class=\"o\">.</span><span class=\"n\">Deflicker</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">Deflicker</span><span class=\"o\">.</span><span class=\"n\">NoDeflicker</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"o\">&gt;</span></span>)</span>"}, {"fullname": "spectralcluster.MultiStageClusterer.deflicker", "modulename": "spectralcluster", "qualname": "MultiStageClusterer.deflicker", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "spectralcluster.MultiStageClusterer.main", "modulename": "spectralcluster", "qualname": "MultiStageClusterer.main", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "spectralcluster.MultiStageClusterer.U1", "modulename": "spectralcluster", "qualname": "MultiStageClusterer.U1", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "spectralcluster.MultiStageClusterer.U2", "modulename": "spectralcluster", "qualname": "MultiStageClusterer.U2", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "spectralcluster.MultiStageClusterer.pre", "modulename": "spectralcluster", "qualname": "MultiStageClusterer.pre", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "spectralcluster.MultiStageClusterer.cache", "modulename": "spectralcluster", "qualname": "MultiStageClusterer.cache", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "spectralcluster.MultiStageClusterer.num_embeddings", "modulename": "spectralcluster", "qualname": "MultiStageClusterer.num_embeddings", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "spectralcluster.MultiStageClusterer.compression_labels", "modulename": "spectralcluster", "qualname": "MultiStageClusterer.compression_labels", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "spectralcluster.MultiStageClusterer.previous_output", "modulename": "spectralcluster", "qualname": "MultiStageClusterer.previous_output", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "spectralcluster.MultiStageClusterer.streaming_predict", "modulename": "spectralcluster", "qualname": "MultiStageClusterer.streaming_predict", "kind": "function", "doc": "<p>A streaming prediction function.</p>\n\n<p>Note that this is not a simple online prediction class It not only\npredicts the label of the next input, but also makes corrections to\npreviously predicted labels.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">embedding</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "spectralcluster.NaiveClusterer", "modulename": "spectralcluster", "qualname": "NaiveClusterer", "kind": "class", "doc": "<p>Naive clustering class.</p>\n"}, {"fullname": "spectralcluster.NaiveClusterer.__init__", "modulename": "spectralcluster", "qualname": "NaiveClusterer.__init__", "kind": "function", "doc": "<p>Initialized the clusterer.</p>\n\n<p>Note that since this is online clustering, fit_predict and predict\nare the same.</p>\n\n<p>Args:\n  threshold: if cosine similarity is larger than this threshold, the\n    embedding will be considered to belong to the cluster\n  adaptation_threshold: if cosine similarity is larger than\n    adaptation_threshold, the embedding will be merged to the cluster.\n    If None, we use threshold as adaptation_threshold</p>\n\n<p>Raises:\n  ValueError: if adaptation_threshold is smaller than threshold</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">threshold</span><span class=\"p\">:</span> <span class=\"nb\">float</span>, </span><span class=\"param\"><span class=\"n\">adaptation_threshold</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span>)</span>"}, {"fullname": "spectralcluster.NaiveClusterer.threshold", "modulename": "spectralcluster", "qualname": "NaiveClusterer.threshold", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "spectralcluster.NaiveClusterer.centroids", "modulename": "spectralcluster", "qualname": "NaiveClusterer.centroids", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "spectralcluster.NaiveClusterer.reset", "modulename": "spectralcluster", "qualname": "NaiveClusterer.reset", "kind": "function", "doc": "<p>Reset the clusterer.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "spectralcluster.NaiveClusterer.predict_next", "modulename": "spectralcluster", "qualname": "NaiveClusterer.predict_next", "kind": "function", "doc": "<p>Given a new embedding, output its label.</p>\n\n<p>This is used for online clustering.</p>\n\n<p>Args:\n  embedding: numpy array of shape (n_features,)</p>\n\n<p>Returns:\n  label: an integer cluster label</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">embedding</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "spectralcluster.NaiveClusterer.predict", "modulename": "spectralcluster", "qualname": "NaiveClusterer.predict", "kind": "function", "doc": "<p>Given many embeddings, return all cluster labels.</p>\n\n<p>This is for simulating offline clustering behavior.</p>\n\n<p>Args:\n  embeddings: numpy array of shape (n_samples, n_features)</p>\n\n<p>Returns:\n  labels: numpy array of shape (n_samples,)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">embeddings</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "spectralcluster.NaiveClusterer.fit_predict", "modulename": "spectralcluster", "qualname": "NaiveClusterer.fit_predict", "kind": "function", "doc": "<p>Same as predict(), since this is an online clusterer.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">embeddings</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "spectralcluster.RefinementName", "modulename": "spectralcluster", "qualname": "RefinementName", "kind": "class", "doc": "<p>The names of the refinement operations.</p>\n", "bases": "enum.Enum"}, {"fullname": "spectralcluster.RefinementName.CropDiagonal", "modulename": "spectralcluster", "qualname": "RefinementName.CropDiagonal", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;RefinementName.CropDiagonal: 1&gt;"}, {"fullname": "spectralcluster.RefinementName.GaussianBlur", "modulename": "spectralcluster", "qualname": "RefinementName.GaussianBlur", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;RefinementName.GaussianBlur: 2&gt;"}, {"fullname": "spectralcluster.RefinementName.RowWiseThreshold", "modulename": "spectralcluster", "qualname": "RefinementName.RowWiseThreshold", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;RefinementName.RowWiseThreshold: 3&gt;"}, {"fullname": "spectralcluster.RefinementName.Symmetrize", "modulename": "spectralcluster", "qualname": "RefinementName.Symmetrize", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;RefinementName.Symmetrize: 4&gt;"}, {"fullname": "spectralcluster.RefinementName.Diffuse", "modulename": "spectralcluster", "qualname": "RefinementName.Diffuse", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;RefinementName.Diffuse: 5&gt;"}, {"fullname": "spectralcluster.RefinementName.RowWiseNormalize", "modulename": "spectralcluster", "qualname": "RefinementName.RowWiseNormalize", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;RefinementName.RowWiseNormalize: 6&gt;"}, {"fullname": "spectralcluster.RefinementOptions", "modulename": "spectralcluster", "qualname": "RefinementOptions", "kind": "class", "doc": "<p>Refinement options for the affinity matrix.</p>\n"}, {"fullname": "spectralcluster.RefinementOptions.__init__", "modulename": "spectralcluster", "qualname": "RefinementOptions.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">gaussian_blur_sigma</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">p_percentile</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.95</span>,</span><span class=\"param\">\t<span class=\"n\">thresholding_soft_multiplier</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.01</span>,</span><span class=\"param\">\t<span class=\"n\">thresholding_type</span><span class=\"p\">:</span> <span class=\"n\">spectralcluster</span><span class=\"o\">.</span><span class=\"n\">refinement</span><span class=\"o\">.</span><span class=\"n\">ThresholdType</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">ThresholdType</span><span class=\"o\">.</span><span class=\"n\">RowMax</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">thresholding_with_binarization</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">thresholding_preserve_diagonal</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">symmetrize_type</span><span class=\"p\">:</span> <span class=\"n\">spectralcluster</span><span class=\"o\">.</span><span class=\"n\">refinement</span><span class=\"o\">.</span><span class=\"n\">SymmetrizeType</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">SymmetrizeType</span><span class=\"o\">.</span><span class=\"n\">Max</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">refinement_sequence</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"n\">spectralcluster</span><span class=\"o\">.</span><span class=\"n\">refinement</span><span class=\"o\">.</span><span class=\"n\">RefinementName</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span>)</span>"}, {"fullname": "spectralcluster.RefinementOptions.gaussian_blur_sigma", "modulename": "spectralcluster", "qualname": "RefinementOptions.gaussian_blur_sigma", "kind": "variable", "doc": "<p></p>\n", "annotation": ": int", "default_value": "1"}, {"fullname": "spectralcluster.RefinementOptions.p_percentile", "modulename": "spectralcluster", "qualname": "RefinementOptions.p_percentile", "kind": "variable", "doc": "<p></p>\n", "annotation": ": float", "default_value": "0.95"}, {"fullname": "spectralcluster.RefinementOptions.thresholding_soft_multiplier", "modulename": "spectralcluster", "qualname": "RefinementOptions.thresholding_soft_multiplier", "kind": "variable", "doc": "<p></p>\n", "annotation": ": float", "default_value": "0.01"}, {"fullname": "spectralcluster.RefinementOptions.thresholding_type", "modulename": "spectralcluster", "qualname": "RefinementOptions.thresholding_type", "kind": "variable", "doc": "<p></p>\n", "annotation": ": spectralcluster.refinement.ThresholdType", "default_value": "&lt;ThresholdType.RowMax: 1&gt;"}, {"fullname": "spectralcluster.RefinementOptions.thresholding_with_binarization", "modulename": "spectralcluster", "qualname": "RefinementOptions.thresholding_with_binarization", "kind": "variable", "doc": "<p></p>\n", "annotation": ": bool", "default_value": "False"}, {"fullname": "spectralcluster.RefinementOptions.thresholding_preserve_diagonal", "modulename": "spectralcluster", "qualname": "RefinementOptions.thresholding_preserve_diagonal", "kind": "variable", "doc": "<p></p>\n", "annotation": ": bool", "default_value": "False"}, {"fullname": "spectralcluster.RefinementOptions.symmetrize_type", "modulename": "spectralcluster", "qualname": "RefinementOptions.symmetrize_type", "kind": "variable", "doc": "<p></p>\n", "annotation": ": spectralcluster.refinement.SymmetrizeType", "default_value": "&lt;SymmetrizeType.Max: 1&gt;"}, {"fullname": "spectralcluster.RefinementOptions.refinement_sequence", "modulename": "spectralcluster", "qualname": "RefinementOptions.refinement_sequence", "kind": "variable", "doc": "<p></p>\n", "annotation": ": Optional[Sequence[spectralcluster.refinement.RefinementName]]", "default_value": "None"}, {"fullname": "spectralcluster.RefinementOptions.get_refinement_operator", "modulename": "spectralcluster", "qualname": "RefinementOptions.get_refinement_operator", "kind": "function", "doc": "<p>Get the refinement operator for the affinity matrix.</p>\n\n<p>Args:\n  name: a RefinementName</p>\n\n<p>Returns:\n  object of the operator</p>\n\n<p>Raises:\n  TypeError: if name is not a RefinementName\n  ValueError: if name is an unknown refinement operation</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">name</span><span class=\"p\">:</span> <span class=\"n\">spectralcluster</span><span class=\"o\">.</span><span class=\"n\">refinement</span><span class=\"o\">.</span><span class=\"n\">RefinementName</span></span><span class=\"return-annotation\">) -> <span class=\"n\">spectralcluster</span><span class=\"o\">.</span><span class=\"n\">refinement</span><span class=\"o\">.</span><span class=\"n\">AffinityRefinementOperation</span>:</span></span>", "funcdef": "def"}, {"fullname": "spectralcluster.ThresholdType", "modulename": "spectralcluster", "qualname": "ThresholdType", "kind": "class", "doc": "<p>Different types of thresholding.</p>\n", "bases": "enum.Enum"}, {"fullname": "spectralcluster.ThresholdType.RowMax", "modulename": "spectralcluster", "qualname": "ThresholdType.RowMax", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;ThresholdType.RowMax: 1&gt;"}, {"fullname": "spectralcluster.ThresholdType.Percentile", "modulename": "spectralcluster", "qualname": "ThresholdType.Percentile", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;ThresholdType.Percentile: 2&gt;"}, {"fullname": "spectralcluster.SymmetrizeType", "modulename": "spectralcluster", "qualname": "SymmetrizeType", "kind": "class", "doc": "<p>Different types of symmetrization operation.</p>\n", "bases": "enum.Enum"}, {"fullname": "spectralcluster.SymmetrizeType.Max", "modulename": "spectralcluster", "qualname": "SymmetrizeType.Max", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;SymmetrizeType.Max: 1&gt;"}, {"fullname": "spectralcluster.SymmetrizeType.Average", "modulename": "spectralcluster", "qualname": "SymmetrizeType.Average", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;SymmetrizeType.Average: 2&gt;"}, {"fullname": "spectralcluster.SpectralClusterer", "modulename": "spectralcluster", "qualname": "SpectralClusterer", "kind": "class", "doc": "<p>Spectral clustering class.</p>\n"}, {"fullname": "spectralcluster.SpectralClusterer.__init__", "modulename": "spectralcluster", "qualname": "SpectralClusterer.__init__", "kind": "function", "doc": "<p>Constructor of the clusterer.</p>\n\n<p>Args:\n  min_clusters: minimal number of clusters allowed (only effective if not\n    None)\n  max_clusters: maximal number of clusters allowed (only effective if not\n    None), can be used together with min_clusters to fix the number of\n    clusters\n  refinement_options: a RefinementOptions object that contains refinement\n    arguments for the affinity matrix. If None, we will not refine\n  autotune: an AutoTune object to automatically search p_percentile\n  fallback_options: a FallbackOptions object to indicate when to run\n    fallback clusterer instead of spectral clusterer\n  laplacian_type: a LaplacianType. If None, we do not use a laplacian matrix\n  stop_eigenvalue: when computing the number of clusters using Eigen Gap, we\n    do not look at eigen values smaller than this value\n  row_wise_renorm: if True, perform row-wise re-normalization on the\n    spectral embeddings\n  custom_dist: str or callable. custom distance measure for k-means. If a\n    string, \"cosine\", \"euclidean\", \"mahalanobis\", or any other distance\n    functions defined in scipy.spatial.distance can be used\n  max_iter: the maximum number of iterations for the custom k-means\n  constraint_options: a ConstraintOptions object that contains constraint\n    arguments\n  eigengap_type: the type of the eigengap computation\n  max_spectral_size: the maximal size of input to the spectral clustering\n    algorithm. If this is set, and the actual input size is larger than\n    this value, then we are going to first use hierarchical clustering\n    to reduce the input size to this number. This can significantly reduce\n    the computational cost for steps like Laplacian matrix and eigen\n    decomposition. However, please note that this may degrade the quality\n    of the final clustering results. This corresponds to the U1 value in\n    the multi-stage clustering paper (<a href=\"https://arxiv.org/abs/2210.13690\">https://arxiv.org/abs/2210.13690</a>)\n  affinity_function: a function to compute the affinity matrix from the\n    embeddings. This defaults to (cos(x,y)+1)/2\n  post_eigen_cluster_function: a function to cluster the spectral embeddings\n    after the eigenvalue computations. This function must have the same\n    signature as custom_distance_kmeans.run_kmeans</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">min_clusters</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">max_clusters</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">refinement_options</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">spectralcluster</span><span class=\"o\">.</span><span class=\"n\">refinement</span><span class=\"o\">.</span><span class=\"n\">RefinementOptions</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">autotune</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">spectralcluster</span><span class=\"o\">.</span><span class=\"n\">autotune</span><span class=\"o\">.</span><span class=\"n\">AutoTune</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">fallback_options</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">spectralcluster</span><span class=\"o\">.</span><span class=\"n\">fallback_clusterer</span><span class=\"o\">.</span><span class=\"n\">FallbackOptions</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">laplacian_type</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">spectralcluster</span><span class=\"o\">.</span><span class=\"n\">laplacian</span><span class=\"o\">.</span><span class=\"n\">LaplacianType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">stop_eigenvalue</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.01</span>,</span><span class=\"param\">\t<span class=\"n\">row_wise_renorm</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">custom_dist</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">Callable</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;cosine&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">max_iter</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">300</span>,</span><span class=\"param\">\t<span class=\"n\">constraint_options</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">spectralcluster</span><span class=\"o\">.</span><span class=\"n\">constraint</span><span class=\"o\">.</span><span class=\"n\">ConstraintOptions</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">eigengap_type</span><span class=\"p\">:</span> <span class=\"n\">spectralcluster</span><span class=\"o\">.</span><span class=\"n\">utils</span><span class=\"o\">.</span><span class=\"n\">EigenGapType</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">EigenGapType</span><span class=\"o\">.</span><span class=\"n\">Ratio</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">max_spectral_size</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">affinity_function</span><span class=\"p\">:</span> <span class=\"n\">Callable</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">function</span> <span class=\"n\">compute_affinity_matrix</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">post_eigen_cluster_function</span><span class=\"p\">:</span> <span class=\"n\">Callable</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">function</span> <span class=\"n\">run_kmeans</span><span class=\"o\">&gt;</span></span>)</span>"}, {"fullname": "spectralcluster.SpectralClusterer.min_clusters", "modulename": "spectralcluster", "qualname": "SpectralClusterer.min_clusters", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "spectralcluster.SpectralClusterer.max_clusters", "modulename": "spectralcluster", "qualname": "SpectralClusterer.max_clusters", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "spectralcluster.SpectralClusterer.autotune", "modulename": "spectralcluster", "qualname": "SpectralClusterer.autotune", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "spectralcluster.SpectralClusterer.laplacian_type", "modulename": "spectralcluster", "qualname": "SpectralClusterer.laplacian_type", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "spectralcluster.SpectralClusterer.row_wise_renorm", "modulename": "spectralcluster", "qualname": "SpectralClusterer.row_wise_renorm", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "spectralcluster.SpectralClusterer.stop_eigenvalue", "modulename": "spectralcluster", "qualname": "SpectralClusterer.stop_eigenvalue", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "spectralcluster.SpectralClusterer.custom_dist", "modulename": "spectralcluster", "qualname": "SpectralClusterer.custom_dist", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "spectralcluster.SpectralClusterer.max_iter", "modulename": "spectralcluster", "qualname": "SpectralClusterer.max_iter", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "spectralcluster.SpectralClusterer.constraint_options", "modulename": "spectralcluster", "qualname": "SpectralClusterer.constraint_options", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "spectralcluster.SpectralClusterer.eigengap_type", "modulename": "spectralcluster", "qualname": "SpectralClusterer.eigengap_type", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "spectralcluster.SpectralClusterer.max_spectral_size", "modulename": "spectralcluster", "qualname": "SpectralClusterer.max_spectral_size", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "spectralcluster.SpectralClusterer.affinity_function", "modulename": "spectralcluster", "qualname": "SpectralClusterer.affinity_function", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "spectralcluster.SpectralClusterer.post_eigen_cluster_function", "modulename": "spectralcluster", "qualname": "SpectralClusterer.post_eigen_cluster_function", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "spectralcluster.SpectralClusterer.predict", "modulename": "spectralcluster", "qualname": "SpectralClusterer.predict", "kind": "function", "doc": "<p>Perform spectral clustering on data embeddings.</p>\n\n<p>The spectral clustering is performed on an affinity matrix.</p>\n\n<p>Args:\n  embeddings: numpy array of shape (n_samples, n_features)\n  constraint_matrix: numpy array of shape (n_samples, n_samples). The\n    constraint matrix with prior information</p>\n\n<p>Returns:\n  labels: numpy array of shape (n_samples,)</p>\n\n<p>Raises:\n  TypeError: if embeddings has wrong type\n  ValueError: if embeddings has wrong shape\n  RuntimeError: if max_spectral_size is set and constraint_matrix is given</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">embeddings</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">constraint_matrix</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "spectralcluster.EigenGapType", "modulename": "spectralcluster", "qualname": "EigenGapType", "kind": "class", "doc": "<p>Different types of the eigengap computation.</p>\n", "bases": "enum.Enum"}, {"fullname": "spectralcluster.EigenGapType.Ratio", "modulename": "spectralcluster", "qualname": "EigenGapType.Ratio", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;EigenGapType.Ratio: 1&gt;"}, {"fullname": "spectralcluster.EigenGapType.NormalizedDiff", "modulename": "spectralcluster", "qualname": "EigenGapType.NormalizedDiff", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;EigenGapType.NormalizedDiff: 2&gt;"}, {"fullname": "spectralcluster.ICASSP2018_REFINEMENT_SEQUENCE", "modulename": "spectralcluster", "qualname": "ICASSP2018_REFINEMENT_SEQUENCE", "kind": "variable", "doc": "<p></p>\n", "default_value": "[&lt;RefinementName.CropDiagonal: 1&gt;, &lt;RefinementName.GaussianBlur: 2&gt;, &lt;RefinementName.RowWiseThreshold: 3&gt;, &lt;RefinementName.Symmetrize: 4&gt;, &lt;RefinementName.Diffuse: 5&gt;, &lt;RefinementName.RowWiseNormalize: 6&gt;]"}, {"fullname": "spectralcluster.TURNTODIARIZE_REFINEMENT_SEQUENCE", "modulename": "spectralcluster", "qualname": "TURNTODIARIZE_REFINEMENT_SEQUENCE", "kind": "variable", "doc": "<p></p>\n", "default_value": "[&lt;RefinementName.RowWiseThreshold: 3&gt;, &lt;RefinementName.Symmetrize: 4&gt;]"}, {"fullname": "spectralcluster.autotune", "modulename": "spectralcluster.autotune", "kind": "module", "doc": "<p>Auto-tuning hyper-parameters.</p>\n"}, {"fullname": "spectralcluster.autotune.MIN_SEARCH_STEP", "modulename": "spectralcluster.autotune", "qualname": "MIN_SEARCH_STEP", "kind": "variable", "doc": "<p></p>\n", "default_value": "0.0001"}, {"fullname": "spectralcluster.autotune.AutoTuneProxy", "modulename": "spectralcluster.autotune", "qualname": "AutoTuneProxy", "kind": "class", "doc": "<p>What proxy to use as the auto-tuning target.</p>\n", "bases": "enum.Enum"}, {"fullname": "spectralcluster.autotune.AutoTuneProxy.PercentileOverNME", "modulename": "spectralcluster.autotune", "qualname": "AutoTuneProxy.PercentileOverNME", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;AutoTuneProxy.PercentileOverNME: 1&gt;"}, {"fullname": "spectralcluster.autotune.AutoTuneProxy.PercentileSqrtOverNME", "modulename": "spectralcluster.autotune", "qualname": "AutoTuneProxy.PercentileSqrtOverNME", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;AutoTuneProxy.PercentileSqrtOverNME: 2&gt;"}, {"fullname": "spectralcluster.autotune.AutoTune", "modulename": "spectralcluster.autotune", "qualname": "AutoTune", "kind": "class", "doc": "<p>AutoTune Class.</p>\n\n<p>This auto-tuning method is implemented based on this paper:\nPark, Tae Jin, et al. \"Auto-tuning spectral clustering for speaker\ndiarization using normalized maximum eigengap.\" IEEE Signal Processing Letter\n2019.</p>\n"}, {"fullname": "spectralcluster.autotune.AutoTune.__init__", "modulename": "spectralcluster.autotune", "qualname": "AutoTune.__init__", "kind": "function", "doc": "<p>Initialization of the autotune arguments.</p>\n\n<p>Args:\n  p_percentile_min: minimum value of p_percentile\n  p_percentile_max: maximum value of p_percentile\n  init_search_step: initial search step size for auto-tuning\n  search_level: hierarchical search level for auto-tuning\n  proxy: which proxy to minimize for auto-tuning</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">p_percentile_min</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.6</span>,</span><span class=\"param\">\t<span class=\"n\">p_percentile_max</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.95</span>,</span><span class=\"param\">\t<span class=\"n\">init_search_step</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.01</span>,</span><span class=\"param\">\t<span class=\"n\">search_level</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">proxy</span><span class=\"p\">:</span> <span class=\"n\">spectralcluster</span><span class=\"o\">.</span><span class=\"n\">autotune</span><span class=\"o\">.</span><span class=\"n\">AutoTuneProxy</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">AutoTuneProxy</span><span class=\"o\">.</span><span class=\"n\">PercentileSqrtOverNME</span><span class=\"p\">:</span> <span class=\"mi\">2</span><span class=\"o\">&gt;</span></span>)</span>"}, {"fullname": "spectralcluster.autotune.AutoTune.p_percentile_min", "modulename": "spectralcluster.autotune", "qualname": "AutoTune.p_percentile_min", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "spectralcluster.autotune.AutoTune.p_percentile_max", "modulename": "spectralcluster.autotune", "qualname": "AutoTune.p_percentile_max", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "spectralcluster.autotune.AutoTune.search_step", "modulename": "spectralcluster.autotune", "qualname": "AutoTune.search_step", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "spectralcluster.autotune.AutoTune.search_level", "modulename": "spectralcluster.autotune", "qualname": "AutoTune.search_level", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "spectralcluster.autotune.AutoTune.proxy", "modulename": "spectralcluster.autotune", "qualname": "AutoTune.proxy", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "spectralcluster.autotune.AutoTune.get_percentile_range", "modulename": "spectralcluster.autotune", "qualname": "AutoTune.get_percentile_range", "kind": "function", "doc": "<p>Get the current percentile search range.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "spectralcluster.autotune.AutoTune.update_percentile_range", "modulename": "spectralcluster.autotune", "qualname": "AutoTune.update_percentile_range", "kind": "function", "doc": "<p>Update the percentile search range.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">p_percentile_min</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">p_percentile_max</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">search_step</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "spectralcluster.autotune.AutoTune.tune", "modulename": "spectralcluster.autotune", "qualname": "AutoTune.tune", "kind": "function", "doc": "<p>Tune the hyper-parameter p_percentile.</p>\n\n<p>Use a proxy ratio of DER to tune the hyper-parameter p_percentile. It also\nperforms some side work to do affinity refinement, eigen decomposition, and\nestimate the number of clusters.</p>\n\n<p>Args:\n  p_percentile_to_ratio: a callable to compute the <code>ratio</code> given a\n    <code>p_percentile</code> value</p>\n\n<p>Returns:\n  eigenvectors: sorted eigenvectors. numpy array of shape\n  (n_samples, n_samples)\n  n_clusters: number of clusters as an integer\n  best_p_percentile: p_percentile value that minimizes the ratio</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">p_percentile_to_ratio</span><span class=\"p\">:</span> <span class=\"n\">Callable</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "spectralcluster.configs", "modulename": "spectralcluster.configs", "kind": "module", "doc": "<p>Example configurations.</p>\n"}, {"fullname": "spectralcluster.configs.AutoTune", "modulename": "spectralcluster.configs", "qualname": "AutoTune", "kind": "class", "doc": "<p>AutoTune Class.</p>\n\n<p>This auto-tuning method is implemented based on this paper:\nPark, Tae Jin, et al. \"Auto-tuning spectral clustering for speaker\ndiarization using normalized maximum eigengap.\" IEEE Signal Processing Letter\n2019.</p>\n"}, {"fullname": "spectralcluster.configs.AutoTune.__init__", "modulename": "spectralcluster.configs", "qualname": "AutoTune.__init__", "kind": "function", "doc": "<p>Initialization of the autotune arguments.</p>\n\n<p>Args:\n  p_percentile_min: minimum value of p_percentile\n  p_percentile_max: maximum value of p_percentile\n  init_search_step: initial search step size for auto-tuning\n  search_level: hierarchical search level for auto-tuning\n  proxy: which proxy to minimize for auto-tuning</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">p_percentile_min</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.6</span>,</span><span class=\"param\">\t<span class=\"n\">p_percentile_max</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.95</span>,</span><span class=\"param\">\t<span class=\"n\">init_search_step</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.01</span>,</span><span class=\"param\">\t<span class=\"n\">search_level</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">proxy</span><span class=\"p\">:</span> <span class=\"n\">spectralcluster</span><span class=\"o\">.</span><span class=\"n\">autotune</span><span class=\"o\">.</span><span class=\"n\">AutoTuneProxy</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">AutoTuneProxy</span><span class=\"o\">.</span><span class=\"n\">PercentileSqrtOverNME</span><span class=\"p\">:</span> <span class=\"mi\">2</span><span class=\"o\">&gt;</span></span>)</span>"}, {"fullname": "spectralcluster.configs.AutoTune.p_percentile_min", "modulename": "spectralcluster.configs", "qualname": "AutoTune.p_percentile_min", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "spectralcluster.configs.AutoTune.p_percentile_max", "modulename": "spectralcluster.configs", "qualname": "AutoTune.p_percentile_max", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "spectralcluster.configs.AutoTune.search_step", "modulename": "spectralcluster.configs", "qualname": "AutoTune.search_step", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "spectralcluster.configs.AutoTune.search_level", "modulename": "spectralcluster.configs", "qualname": "AutoTune.search_level", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "spectralcluster.configs.AutoTune.proxy", "modulename": "spectralcluster.configs", "qualname": "AutoTune.proxy", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "spectralcluster.configs.AutoTune.get_percentile_range", "modulename": "spectralcluster.configs", "qualname": "AutoTune.get_percentile_range", "kind": "function", "doc": "<p>Get the current percentile search range.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "spectralcluster.configs.AutoTune.update_percentile_range", "modulename": "spectralcluster.configs", "qualname": "AutoTune.update_percentile_range", "kind": "function", "doc": "<p>Update the percentile search range.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">p_percentile_min</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">p_percentile_max</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">search_step</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "spectralcluster.configs.AutoTune.tune", "modulename": "spectralcluster.configs", "qualname": "AutoTune.tune", "kind": "function", "doc": "<p>Tune the hyper-parameter p_percentile.</p>\n\n<p>Use a proxy ratio of DER to tune the hyper-parameter p_percentile. It also\nperforms some side work to do affinity refinement, eigen decomposition, and\nestimate the number of clusters.</p>\n\n<p>Args:\n  p_percentile_to_ratio: a callable to compute the <code>ratio</code> given a\n    <code>p_percentile</code> value</p>\n\n<p>Returns:\n  eigenvectors: sorted eigenvectors. numpy array of shape\n  (n_samples, n_samples)\n  n_clusters: number of clusters as an integer\n  best_p_percentile: p_percentile value that minimizes the ratio</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">p_percentile_to_ratio</span><span class=\"p\">:</span> <span class=\"n\">Callable</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "spectralcluster.configs.ConstraintName", "modulename": "spectralcluster.configs", "qualname": "ConstraintName", "kind": "class", "doc": "<p>The names of constrained operations.</p>\n", "bases": "enum.Enum"}, {"fullname": "spectralcluster.configs.ConstraintName.AffinityIntegration", "modulename": "spectralcluster.configs", "qualname": "ConstraintName.AffinityIntegration", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;ConstraintName.AffinityIntegration: 1&gt;"}, {"fullname": "spectralcluster.configs.ConstraintName.ConstraintPropagation", "modulename": "spectralcluster.configs", "qualname": "ConstraintName.ConstraintPropagation", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;ConstraintName.ConstraintPropagation: 2&gt;"}, {"fullname": "spectralcluster.configs.ConstraintOptions", "modulename": "spectralcluster.configs", "qualname": "ConstraintOptions", "kind": "class", "doc": "<p>Constraint options for constrained clustering methods.</p>\n"}, {"fullname": "spectralcluster.configs.ConstraintOptions.__init__", "modulename": "spectralcluster.configs", "qualname": "ConstraintOptions.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">constraint_name</span><span class=\"p\">:</span> <span class=\"n\">spectralcluster</span><span class=\"o\">.</span><span class=\"n\">constraint</span><span class=\"o\">.</span><span class=\"n\">ConstraintName</span>,</span><span class=\"param\">\t<span class=\"n\">apply_before_refinement</span><span class=\"p\">:</span> <span class=\"nb\">bool</span>,</span><span class=\"param\">\t<span class=\"n\">integration_type</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">spectralcluster</span><span class=\"o\">.</span><span class=\"n\">constraint</span><span class=\"o\">.</span><span class=\"n\">IntegrationType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">constraint_propagation_alpha</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.6</span></span>)</span>"}, {"fullname": "spectralcluster.configs.ConstraintOptions.constraint_name", "modulename": "spectralcluster.configs", "qualname": "ConstraintOptions.constraint_name", "kind": "variable", "doc": "<p></p>\n", "annotation": ": spectralcluster.constraint.ConstraintName"}, {"fullname": "spectralcluster.configs.ConstraintOptions.apply_before_refinement", "modulename": "spectralcluster.configs", "qualname": "ConstraintOptions.apply_before_refinement", "kind": "variable", "doc": "<p></p>\n", "annotation": ": bool"}, {"fullname": "spectralcluster.configs.ConstraintOptions.integration_type", "modulename": "spectralcluster.configs", "qualname": "ConstraintOptions.integration_type", "kind": "variable", "doc": "<p></p>\n", "annotation": ": Optional[spectralcluster.constraint.IntegrationType]", "default_value": "None"}, {"fullname": "spectralcluster.configs.ConstraintOptions.constraint_propagation_alpha", "modulename": "spectralcluster.configs", "qualname": "ConstraintOptions.constraint_propagation_alpha", "kind": "variable", "doc": "<p></p>\n", "annotation": ": float", "default_value": "0.6"}, {"fullname": "spectralcluster.configs.RefinementName", "modulename": "spectralcluster.configs", "qualname": "RefinementName", "kind": "class", "doc": "<p>The names of the refinement operations.</p>\n", "bases": "enum.Enum"}, {"fullname": "spectralcluster.configs.RefinementName.CropDiagonal", "modulename": "spectralcluster.configs", "qualname": "RefinementName.CropDiagonal", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;RefinementName.CropDiagonal: 1&gt;"}, {"fullname": "spectralcluster.configs.RefinementName.GaussianBlur", "modulename": "spectralcluster.configs", "qualname": "RefinementName.GaussianBlur", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;RefinementName.GaussianBlur: 2&gt;"}, {"fullname": "spectralcluster.configs.RefinementName.RowWiseThreshold", "modulename": "spectralcluster.configs", "qualname": "RefinementName.RowWiseThreshold", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;RefinementName.RowWiseThreshold: 3&gt;"}, {"fullname": "spectralcluster.configs.RefinementName.Symmetrize", "modulename": "spectralcluster.configs", "qualname": "RefinementName.Symmetrize", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;RefinementName.Symmetrize: 4&gt;"}, {"fullname": "spectralcluster.configs.RefinementName.Diffuse", "modulename": "spectralcluster.configs", "qualname": "RefinementName.Diffuse", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;RefinementName.Diffuse: 5&gt;"}, {"fullname": "spectralcluster.configs.RefinementName.RowWiseNormalize", "modulename": "spectralcluster.configs", "qualname": "RefinementName.RowWiseNormalize", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;RefinementName.RowWiseNormalize: 6&gt;"}, {"fullname": "spectralcluster.configs.RefinementOptions", "modulename": "spectralcluster.configs", "qualname": "RefinementOptions", "kind": "class", "doc": "<p>Refinement options for the affinity matrix.</p>\n"}, {"fullname": "spectralcluster.configs.RefinementOptions.__init__", "modulename": "spectralcluster.configs", "qualname": "RefinementOptions.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">gaussian_blur_sigma</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">p_percentile</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.95</span>,</span><span class=\"param\">\t<span class=\"n\">thresholding_soft_multiplier</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.01</span>,</span><span class=\"param\">\t<span class=\"n\">thresholding_type</span><span class=\"p\">:</span> <span class=\"n\">spectralcluster</span><span class=\"o\">.</span><span class=\"n\">refinement</span><span class=\"o\">.</span><span class=\"n\">ThresholdType</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">ThresholdType</span><span class=\"o\">.</span><span class=\"n\">RowMax</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">thresholding_with_binarization</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">thresholding_preserve_diagonal</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">symmetrize_type</span><span class=\"p\">:</span> <span class=\"n\">spectralcluster</span><span class=\"o\">.</span><span class=\"n\">refinement</span><span class=\"o\">.</span><span class=\"n\">SymmetrizeType</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">SymmetrizeType</span><span class=\"o\">.</span><span class=\"n\">Max</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">refinement_sequence</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"n\">spectralcluster</span><span class=\"o\">.</span><span class=\"n\">refinement</span><span class=\"o\">.</span><span class=\"n\">RefinementName</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span>)</span>"}, {"fullname": "spectralcluster.configs.RefinementOptions.gaussian_blur_sigma", "modulename": "spectralcluster.configs", "qualname": "RefinementOptions.gaussian_blur_sigma", "kind": "variable", "doc": "<p></p>\n", "annotation": ": int", "default_value": "1"}, {"fullname": "spectralcluster.configs.RefinementOptions.p_percentile", "modulename": "spectralcluster.configs", "qualname": "RefinementOptions.p_percentile", "kind": "variable", "doc": "<p></p>\n", "annotation": ": float", "default_value": "0.95"}, {"fullname": "spectralcluster.configs.RefinementOptions.thresholding_soft_multiplier", "modulename": "spectralcluster.configs", "qualname": "RefinementOptions.thresholding_soft_multiplier", "kind": "variable", "doc": "<p></p>\n", "annotation": ": float", "default_value": "0.01"}, {"fullname": "spectralcluster.configs.RefinementOptions.thresholding_type", "modulename": "spectralcluster.configs", "qualname": "RefinementOptions.thresholding_type", "kind": "variable", "doc": "<p></p>\n", "annotation": ": spectralcluster.refinement.ThresholdType", "default_value": "&lt;ThresholdType.RowMax: 1&gt;"}, {"fullname": "spectralcluster.configs.RefinementOptions.thresholding_with_binarization", "modulename": "spectralcluster.configs", "qualname": "RefinementOptions.thresholding_with_binarization", "kind": "variable", "doc": "<p></p>\n", "annotation": ": bool", "default_value": "False"}, {"fullname": "spectralcluster.configs.RefinementOptions.thresholding_preserve_diagonal", "modulename": "spectralcluster.configs", "qualname": "RefinementOptions.thresholding_preserve_diagonal", "kind": "variable", "doc": "<p></p>\n", "annotation": ": bool", "default_value": "False"}, {"fullname": "spectralcluster.configs.RefinementOptions.symmetrize_type", "modulename": "spectralcluster.configs", "qualname": "RefinementOptions.symmetrize_type", "kind": "variable", "doc": "<p></p>\n", "annotation": ": spectralcluster.refinement.SymmetrizeType", "default_value": "&lt;SymmetrizeType.Max: 1&gt;"}, {"fullname": "spectralcluster.configs.RefinementOptions.refinement_sequence", "modulename": "spectralcluster.configs", "qualname": "RefinementOptions.refinement_sequence", "kind": "variable", "doc": "<p></p>\n", "annotation": ": Optional[Sequence[spectralcluster.refinement.RefinementName]]", "default_value": "None"}, {"fullname": "spectralcluster.configs.RefinementOptions.get_refinement_operator", "modulename": "spectralcluster.configs", "qualname": "RefinementOptions.get_refinement_operator", "kind": "function", "doc": "<p>Get the refinement operator for the affinity matrix.</p>\n\n<p>Args:\n  name: a RefinementName</p>\n\n<p>Returns:\n  object of the operator</p>\n\n<p>Raises:\n  TypeError: if name is not a RefinementName\n  ValueError: if name is an unknown refinement operation</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">name</span><span class=\"p\">:</span> <span class=\"n\">spectralcluster</span><span class=\"o\">.</span><span class=\"n\">refinement</span><span class=\"o\">.</span><span class=\"n\">RefinementName</span></span><span class=\"return-annotation\">) -> <span class=\"n\">spectralcluster</span><span class=\"o\">.</span><span class=\"n\">refinement</span><span class=\"o\">.</span><span class=\"n\">AffinityRefinementOperation</span>:</span></span>", "funcdef": "def"}, {"fullname": "spectralcluster.configs.ThresholdType", "modulename": "spectralcluster.configs", "qualname": "ThresholdType", "kind": "class", "doc": "<p>Different types of thresholding.</p>\n", "bases": "enum.Enum"}, {"fullname": "spectralcluster.configs.ThresholdType.RowMax", "modulename": "spectralcluster.configs", "qualname": "ThresholdType.RowMax", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;ThresholdType.RowMax: 1&gt;"}, {"fullname": "spectralcluster.configs.ThresholdType.Percentile", "modulename": "spectralcluster.configs", "qualname": "ThresholdType.Percentile", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;ThresholdType.Percentile: 2&gt;"}, {"fullname": "spectralcluster.configs.SymmetrizeType", "modulename": "spectralcluster.configs", "qualname": "SymmetrizeType", "kind": "class", "doc": "<p>Different types of symmetrization operation.</p>\n", "bases": "enum.Enum"}, {"fullname": "spectralcluster.configs.SymmetrizeType.Max", "modulename": "spectralcluster.configs", "qualname": "SymmetrizeType.Max", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;SymmetrizeType.Max: 1&gt;"}, {"fullname": "spectralcluster.configs.SymmetrizeType.Average", "modulename": "spectralcluster.configs", "qualname": "SymmetrizeType.Average", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;SymmetrizeType.Average: 2&gt;"}, {"fullname": "spectralcluster.configs.LaplacianType", "modulename": "spectralcluster.configs", "qualname": "LaplacianType", "kind": "class", "doc": "<p>Different types of Laplacian matrix.</p>\n", "bases": "enum.Enum"}, {"fullname": "spectralcluster.configs.LaplacianType.Affinity", "modulename": "spectralcluster.configs", "qualname": "LaplacianType.Affinity", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;LaplacianType.Affinity: 1&gt;"}, {"fullname": "spectralcluster.configs.LaplacianType.Unnormalized", "modulename": "spectralcluster.configs", "qualname": "LaplacianType.Unnormalized", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;LaplacianType.Unnormalized: 2&gt;"}, {"fullname": "spectralcluster.configs.LaplacianType.RandomWalk", "modulename": "spectralcluster.configs", "qualname": "LaplacianType.RandomWalk", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;LaplacianType.RandomWalk: 3&gt;"}, {"fullname": "spectralcluster.configs.LaplacianType.GraphCut", "modulename": "spectralcluster.configs", "qualname": "LaplacianType.GraphCut", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;LaplacianType.GraphCut: 4&gt;"}, {"fullname": "spectralcluster.configs.SpectralClusterer", "modulename": "spectralcluster.configs", "qualname": "SpectralClusterer", "kind": "class", "doc": "<p>Spectral clustering class.</p>\n"}, {"fullname": "spectralcluster.configs.SpectralClusterer.__init__", "modulename": "spectralcluster.configs", "qualname": "SpectralClusterer.__init__", "kind": "function", "doc": "<p>Constructor of the clusterer.</p>\n\n<p>Args:\n  min_clusters: minimal number of clusters allowed (only effective if not\n    None)\n  max_clusters: maximal number of clusters allowed (only effective if not\n    None), can be used together with min_clusters to fix the number of\n    clusters\n  refinement_options: a RefinementOptions object that contains refinement\n    arguments for the affinity matrix. If None, we will not refine\n  autotune: an AutoTune object to automatically search p_percentile\n  fallback_options: a FallbackOptions object to indicate when to run\n    fallback clusterer instead of spectral clusterer\n  laplacian_type: a LaplacianType. If None, we do not use a laplacian matrix\n  stop_eigenvalue: when computing the number of clusters using Eigen Gap, we\n    do not look at eigen values smaller than this value\n  row_wise_renorm: if True, perform row-wise re-normalization on the\n    spectral embeddings\n  custom_dist: str or callable. custom distance measure for k-means. If a\n    string, \"cosine\", \"euclidean\", \"mahalanobis\", or any other distance\n    functions defined in scipy.spatial.distance can be used\n  max_iter: the maximum number of iterations for the custom k-means\n  constraint_options: a ConstraintOptions object that contains constraint\n    arguments\n  eigengap_type: the type of the eigengap computation\n  max_spectral_size: the maximal size of input to the spectral clustering\n    algorithm. If this is set, and the actual input size is larger than\n    this value, then we are going to first use hierarchical clustering\n    to reduce the input size to this number. This can significantly reduce\n    the computational cost for steps like Laplacian matrix and eigen\n    decomposition. However, please note that this may degrade the quality\n    of the final clustering results. This corresponds to the U1 value in\n    the multi-stage clustering paper (<a href=\"https://arxiv.org/abs/2210.13690\">https://arxiv.org/abs/2210.13690</a>)\n  affinity_function: a function to compute the affinity matrix from the\n    embeddings. This defaults to (cos(x,y)+1)/2\n  post_eigen_cluster_function: a function to cluster the spectral embeddings\n    after the eigenvalue computations. This function must have the same\n    signature as custom_distance_kmeans.run_kmeans</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">min_clusters</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">max_clusters</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">refinement_options</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">spectralcluster</span><span class=\"o\">.</span><span class=\"n\">refinement</span><span class=\"o\">.</span><span class=\"n\">RefinementOptions</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">autotune</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">spectralcluster</span><span class=\"o\">.</span><span class=\"n\">autotune</span><span class=\"o\">.</span><span class=\"n\">AutoTune</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">fallback_options</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">spectralcluster</span><span class=\"o\">.</span><span class=\"n\">fallback_clusterer</span><span class=\"o\">.</span><span class=\"n\">FallbackOptions</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">laplacian_type</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">spectralcluster</span><span class=\"o\">.</span><span class=\"n\">laplacian</span><span class=\"o\">.</span><span class=\"n\">LaplacianType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">stop_eigenvalue</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.01</span>,</span><span class=\"param\">\t<span class=\"n\">row_wise_renorm</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">custom_dist</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">Callable</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;cosine&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">max_iter</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">300</span>,</span><span class=\"param\">\t<span class=\"n\">constraint_options</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">spectralcluster</span><span class=\"o\">.</span><span class=\"n\">constraint</span><span class=\"o\">.</span><span class=\"n\">ConstraintOptions</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">eigengap_type</span><span class=\"p\">:</span> <span class=\"n\">spectralcluster</span><span class=\"o\">.</span><span class=\"n\">utils</span><span class=\"o\">.</span><span class=\"n\">EigenGapType</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">EigenGapType</span><span class=\"o\">.</span><span class=\"n\">Ratio</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">max_spectral_size</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">affinity_function</span><span class=\"p\">:</span> <span class=\"n\">Callable</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">function</span> <span class=\"n\">compute_affinity_matrix</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">post_eigen_cluster_function</span><span class=\"p\">:</span> <span class=\"n\">Callable</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">function</span> <span class=\"n\">run_kmeans</span><span class=\"o\">&gt;</span></span>)</span>"}, {"fullname": "spectralcluster.configs.SpectralClusterer.min_clusters", "modulename": "spectralcluster.configs", "qualname": "SpectralClusterer.min_clusters", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "spectralcluster.configs.SpectralClusterer.max_clusters", "modulename": "spectralcluster.configs", "qualname": "SpectralClusterer.max_clusters", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "spectralcluster.configs.SpectralClusterer.autotune", "modulename": "spectralcluster.configs", "qualname": "SpectralClusterer.autotune", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "spectralcluster.configs.SpectralClusterer.laplacian_type", "modulename": "spectralcluster.configs", "qualname": "SpectralClusterer.laplacian_type", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "spectralcluster.configs.SpectralClusterer.row_wise_renorm", "modulename": "spectralcluster.configs", "qualname": "SpectralClusterer.row_wise_renorm", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "spectralcluster.configs.SpectralClusterer.stop_eigenvalue", "modulename": "spectralcluster.configs", "qualname": "SpectralClusterer.stop_eigenvalue", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "spectralcluster.configs.SpectralClusterer.custom_dist", "modulename": "spectralcluster.configs", "qualname": "SpectralClusterer.custom_dist", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "spectralcluster.configs.SpectralClusterer.max_iter", "modulename": "spectralcluster.configs", "qualname": "SpectralClusterer.max_iter", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "spectralcluster.configs.SpectralClusterer.constraint_options", "modulename": "spectralcluster.configs", "qualname": "SpectralClusterer.constraint_options", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "spectralcluster.configs.SpectralClusterer.eigengap_type", "modulename": "spectralcluster.configs", "qualname": "SpectralClusterer.eigengap_type", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "spectralcluster.configs.SpectralClusterer.max_spectral_size", "modulename": "spectralcluster.configs", "qualname": "SpectralClusterer.max_spectral_size", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "spectralcluster.configs.SpectralClusterer.affinity_function", "modulename": "spectralcluster.configs", "qualname": "SpectralClusterer.affinity_function", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "spectralcluster.configs.SpectralClusterer.post_eigen_cluster_function", "modulename": "spectralcluster.configs", "qualname": "SpectralClusterer.post_eigen_cluster_function", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "spectralcluster.configs.SpectralClusterer.predict", "modulename": "spectralcluster.configs", "qualname": "SpectralClusterer.predict", "kind": "function", "doc": "<p>Perform spectral clustering on data embeddings.</p>\n\n<p>The spectral clustering is performed on an affinity matrix.</p>\n\n<p>Args:\n  embeddings: numpy array of shape (n_samples, n_features)\n  constraint_matrix: numpy array of shape (n_samples, n_samples). The\n    constraint matrix with prior information</p>\n\n<p>Returns:\n  labels: numpy array of shape (n_samples,)</p>\n\n<p>Raises:\n  TypeError: if embeddings has wrong type\n  ValueError: if embeddings has wrong shape\n  RuntimeError: if max_spectral_size is set and constraint_matrix is given</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">embeddings</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">constraint_matrix</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "spectralcluster.configs.ICASSP2018_REFINEMENT_SEQUENCE", "modulename": "spectralcluster.configs", "qualname": "ICASSP2018_REFINEMENT_SEQUENCE", "kind": "variable", "doc": "<p></p>\n", "default_value": "[&lt;RefinementName.CropDiagonal: 1&gt;, &lt;RefinementName.GaussianBlur: 2&gt;, &lt;RefinementName.RowWiseThreshold: 3&gt;, &lt;RefinementName.Symmetrize: 4&gt;, &lt;RefinementName.Diffuse: 5&gt;, &lt;RefinementName.RowWiseNormalize: 6&gt;]"}, {"fullname": "spectralcluster.configs.icassp2018_refinement_options", "modulename": "spectralcluster.configs", "qualname": "icassp2018_refinement_options", "kind": "variable", "doc": "<p></p>\n", "default_value": "RefinementOptions(gaussian_blur_sigma=1, p_percentile=0.95, thresholding_soft_multiplier=0.01, thresholding_type=&lt;ThresholdType.RowMax: 1&gt;, thresholding_with_binarization=False, thresholding_preserve_diagonal=False, symmetrize_type=&lt;SymmetrizeType.Max: 1&gt;, refinement_sequence=[&lt;RefinementName.CropDiagonal: 1&gt;, &lt;RefinementName.GaussianBlur: 2&gt;, &lt;RefinementName.RowWiseThreshold: 3&gt;, &lt;RefinementName.Symmetrize: 4&gt;, &lt;RefinementName.Diffuse: 5&gt;, &lt;RefinementName.RowWiseNormalize: 6&gt;])"}, {"fullname": "spectralcluster.configs.icassp2018_clusterer", "modulename": "spectralcluster.configs", "qualname": "icassp2018_clusterer", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;spectralcluster.spectral_clusterer.SpectralClusterer object&gt;"}, {"fullname": "spectralcluster.configs.TURNTODIARIZE_REFINEMENT_SEQUENCE", "modulename": "spectralcluster.configs", "qualname": "TURNTODIARIZE_REFINEMENT_SEQUENCE", "kind": "variable", "doc": "<p></p>\n", "default_value": "[&lt;RefinementName.RowWiseThreshold: 3&gt;, &lt;RefinementName.Symmetrize: 4&gt;]"}, {"fullname": "spectralcluster.configs.turntodiarize_refinement_options", "modulename": "spectralcluster.configs", "qualname": "turntodiarize_refinement_options", "kind": "variable", "doc": "<p></p>\n", "default_value": "RefinementOptions(gaussian_blur_sigma=1, p_percentile=0.95, thresholding_soft_multiplier=0.01, thresholding_type=&lt;ThresholdType.Percentile: 2&gt;, thresholding_with_binarization=True, thresholding_preserve_diagonal=True, symmetrize_type=&lt;SymmetrizeType.Average: 2&gt;, refinement_sequence=[&lt;RefinementName.RowWiseThreshold: 3&gt;, &lt;RefinementName.Symmetrize: 4&gt;])"}, {"fullname": "spectralcluster.configs.turntodiarize_constraint_options", "modulename": "spectralcluster.configs", "qualname": "turntodiarize_constraint_options", "kind": "variable", "doc": "<p></p>\n", "default_value": "ConstraintOptions(constraint_name=&lt;ConstraintName.ConstraintPropagation: 2&gt;, apply_before_refinement=True, integration_type=None, constraint_propagation_alpha=0.4)"}, {"fullname": "spectralcluster.configs.turntodiarize_auto_tune", "modulename": "spectralcluster.configs", "qualname": "turntodiarize_auto_tune", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;spectralcluster.autotune.AutoTune object&gt;"}, {"fullname": "spectralcluster.configs.turntodiarize_clusterer", "modulename": "spectralcluster.configs", "qualname": "turntodiarize_clusterer", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;spectralcluster.spectral_clusterer.SpectralClusterer object&gt;"}, {"fullname": "spectralcluster.constraint", "modulename": "spectralcluster.constraint", "kind": "module", "doc": "<p>Constraint information.</p>\n"}, {"fullname": "spectralcluster.constraint.EPS", "modulename": "spectralcluster.constraint", "qualname": "EPS", "kind": "variable", "doc": "<p></p>\n", "default_value": "1e-10"}, {"fullname": "spectralcluster.constraint.ConstraintName", "modulename": "spectralcluster.constraint", "qualname": "ConstraintName", "kind": "class", "doc": "<p>The names of constrained operations.</p>\n", "bases": "enum.Enum"}, {"fullname": "spectralcluster.constraint.ConstraintName.AffinityIntegration", "modulename": "spectralcluster.constraint", "qualname": "ConstraintName.AffinityIntegration", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;ConstraintName.AffinityIntegration: 1&gt;"}, {"fullname": "spectralcluster.constraint.ConstraintName.ConstraintPropagation", "modulename": "spectralcluster.constraint", "qualname": "ConstraintName.ConstraintPropagation", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;ConstraintName.ConstraintPropagation: 2&gt;"}, {"fullname": "spectralcluster.constraint.IntegrationType", "modulename": "spectralcluster.constraint", "qualname": "IntegrationType", "kind": "class", "doc": "<p>The integration types for the Affinity Integration method.</p>\n", "bases": "enum.Enum"}, {"fullname": "spectralcluster.constraint.IntegrationType.Max", "modulename": "spectralcluster.constraint", "qualname": "IntegrationType.Max", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;IntegrationType.Max: 1&gt;"}, {"fullname": "spectralcluster.constraint.IntegrationType.Average", "modulename": "spectralcluster.constraint", "qualname": "IntegrationType.Average", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;IntegrationType.Average: 2&gt;"}, {"fullname": "spectralcluster.constraint.ConstraintOptions", "modulename": "spectralcluster.constraint", "qualname": "ConstraintOptions", "kind": "class", "doc": "<p>Constraint options for constrained clustering methods.</p>\n"}, {"fullname": "spectralcluster.constraint.ConstraintOptions.__init__", "modulename": "spectralcluster.constraint", "qualname": "ConstraintOptions.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">constraint_name</span><span class=\"p\">:</span> <span class=\"n\">spectralcluster</span><span class=\"o\">.</span><span class=\"n\">constraint</span><span class=\"o\">.</span><span class=\"n\">ConstraintName</span>,</span><span class=\"param\">\t<span class=\"n\">apply_before_refinement</span><span class=\"p\">:</span> <span class=\"nb\">bool</span>,</span><span class=\"param\">\t<span class=\"n\">integration_type</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">spectralcluster</span><span class=\"o\">.</span><span class=\"n\">constraint</span><span class=\"o\">.</span><span class=\"n\">IntegrationType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">constraint_propagation_alpha</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.6</span></span>)</span>"}, {"fullname": "spectralcluster.constraint.ConstraintOptions.constraint_name", "modulename": "spectralcluster.constraint", "qualname": "ConstraintOptions.constraint_name", "kind": "variable", "doc": "<p></p>\n", "annotation": ": spectralcluster.constraint.ConstraintName"}, {"fullname": "spectralcluster.constraint.ConstraintOptions.apply_before_refinement", "modulename": "spectralcluster.constraint", "qualname": "ConstraintOptions.apply_before_refinement", "kind": "variable", "doc": "<p></p>\n", "annotation": ": bool"}, {"fullname": "spectralcluster.constraint.ConstraintOptions.integration_type", "modulename": "spectralcluster.constraint", "qualname": "ConstraintOptions.integration_type", "kind": "variable", "doc": "<p></p>\n", "annotation": ": Optional[spectralcluster.constraint.IntegrationType]", "default_value": "None"}, {"fullname": "spectralcluster.constraint.ConstraintOptions.constraint_propagation_alpha", "modulename": "spectralcluster.constraint", "qualname": "ConstraintOptions.constraint_propagation_alpha", "kind": "variable", "doc": "<p></p>\n", "annotation": ": float", "default_value": "0.6"}, {"fullname": "spectralcluster.constraint.ConstraintOperation", "modulename": "spectralcluster.constraint", "qualname": "ConstraintOperation", "kind": "class", "doc": "<p>Constraint operation class.</p>\n"}, {"fullname": "spectralcluster.constraint.ConstraintOperation.check_input", "modulename": "spectralcluster.constraint", "qualname": "ConstraintOperation.check_input", "kind": "function", "doc": "<p>Check the input to the adjust_affinity method.</p>\n\n<p>Args:\n  affinity: the input affinity matrix.\n  constraint_matrix: numpy array of shape (n_samples, n_samples). The\n    constraint matrix with prior information</p>\n\n<p>Raises:\n  ValueError: if affinity or constraint matrix has wrong shape, etc.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">affinity</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">constraint_matrix</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "spectralcluster.constraint.ConstraintOperation.adjust_affinity", "modulename": "spectralcluster.constraint", "qualname": "ConstraintOperation.adjust_affinity", "kind": "function", "doc": "<p>An abstract method to perform the constraint operation.</p>\n\n<p>Args:\n  affinity: the affinity matrix, of size (n_samples, n_samples)\n  constraint_matrix: numpy array of shape (n_samples, n_samples). The\n    constraint matrix with prior information</p>\n\n<p>Returns:\n  a matrix of the same size as affinity</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">affinity</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">constraint_matrix</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "spectralcluster.constraint.AffinityIntegration", "modulename": "spectralcluster.constraint", "qualname": "AffinityIntegration", "kind": "class", "doc": "<p>The Affinity Integration method.</p>\n\n<p>Basic operations to integrate the affinity matrix with given pairwise\nconstraints in the constraint matrix. Current integration types include <code>Max</code>\nand <code>Average</code>.</p>\n", "bases": "ConstraintOperation"}, {"fullname": "spectralcluster.constraint.AffinityIntegration.__init__", "modulename": "spectralcluster.constraint", "qualname": "AffinityIntegration.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">integration_type</span><span class=\"p\">:</span> <span class=\"n\">spectralcluster</span><span class=\"o\">.</span><span class=\"n\">constraint</span><span class=\"o\">.</span><span class=\"n\">IntegrationType</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">IntegrationType</span><span class=\"o\">.</span><span class=\"n\">Max</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"o\">&gt;</span></span>)</span>"}, {"fullname": "spectralcluster.constraint.AffinityIntegration.integration_type", "modulename": "spectralcluster.constraint", "qualname": "AffinityIntegration.integration_type", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "spectralcluster.constraint.AffinityIntegration.adjust_affinity", "modulename": "spectralcluster.constraint", "qualname": "AffinityIntegration.adjust_affinity", "kind": "function", "doc": "<p>Adjust the affinity matrix with constraints.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">affinity</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">constraint_matrix</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "spectralcluster.constraint.ConstraintPropagation", "modulename": "spectralcluster.constraint", "qualname": "ConstraintPropagation", "kind": "class", "doc": "<p>The Constraint Propagation method.</p>\n\n<p>The pairwise constraints are firstly propagated throughout the whole graph by\ntwo independent horizontal and vertical propagations. The final propagated\nconstraint matrix is applied to adjust the affinity matrix.</p>\n\n<p>Reference:\n[1] Lu, Zhiwu, and IP, Horace HS. \"Constrained spectral clustering via\nexhaustive and efficient constraint propagation.\" ECCV 2010\n[2] Lu, Zhiwu, and Peng, Yuxin. \"Exhaustive and efficient constraint\npropagation: A graph-based learning approach and its applications.\" IJCV 2013</p>\n", "bases": "ConstraintOperation"}, {"fullname": "spectralcluster.constraint.ConstraintPropagation.__init__", "modulename": "spectralcluster.constraint", "qualname": "ConstraintPropagation.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">alpha</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.6</span></span>)</span>"}, {"fullname": "spectralcluster.constraint.ConstraintPropagation.alpha", "modulename": "spectralcluster.constraint", "qualname": "ConstraintPropagation.alpha", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "spectralcluster.constraint.ConstraintPropagation.adjust_affinity", "modulename": "spectralcluster.constraint", "qualname": "ConstraintPropagation.adjust_affinity", "kind": "function", "doc": "<p>Adjust the affinity matrix with constraints.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">affinity</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">constraint_matrix</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "spectralcluster.constraint.ConstraintMatrix", "modulename": "spectralcluster.constraint", "qualname": "ConstraintMatrix", "kind": "class", "doc": "<p>Constraint Matrix class.</p>\n"}, {"fullname": "spectralcluster.constraint.ConstraintMatrix.__init__", "modulename": "spectralcluster.constraint", "qualname": "ConstraintMatrix.__init__", "kind": "function", "doc": "<p>Initialization of the constraint matrix arguments.</p>\n\n<p>Args:\n  speaker_turn_scores: A list of speaker turn confidence scores. All score\n    values are larger or equal to 0. If score is 0, there is no speaker\n    turn. speaker_turn_scores[i+1] means the speaker turn confidence score\n    between turn i+1 and turn i. The first score speaker_turn_scores[0] is\n    not used.\n  threshold: A threshold value for the speaker turn confidence score.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">speaker_turn_scores</span><span class=\"p\">:</span> <span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span>, </span><span class=\"param\"><span class=\"n\">threshold</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mi\">1</span></span>)</span>"}, {"fullname": "spectralcluster.constraint.ConstraintMatrix.speaker_turn_scores", "modulename": "spectralcluster.constraint", "qualname": "ConstraintMatrix.speaker_turn_scores", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "spectralcluster.constraint.ConstraintMatrix.threshold", "modulename": "spectralcluster.constraint", "qualname": "ConstraintMatrix.threshold", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "spectralcluster.constraint.ConstraintMatrix.compute_diagonals", "modulename": "spectralcluster.constraint", "qualname": "ConstraintMatrix.compute_diagonals", "kind": "function", "doc": "<p>Compute diagonal constraint matrix.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "spectralcluster.custom_distance_kmeans", "modulename": "spectralcluster.custom_distance_kmeans", "kind": "module", "doc": "<p>Implement custom kmeans.</p>\n\n<p>It supports any distance measure defined in scipy.spatial.distance.</p>\n"}, {"fullname": "spectralcluster.custom_distance_kmeans.run_kmeans", "modulename": "spectralcluster.custom_distance_kmeans", "qualname": "run_kmeans", "kind": "function", "doc": "<p>Run CustomKMeans with a custom distance measure support.</p>\n\n<p>Perform a custom kmeans clustering with any distance measure defined\nin scipy.spatial.distance.</p>\n\n<p>Args:\n  spectral_embeddings: input spectracl embedding observations\n  n_clusters: the number of clusters to form\n  custom_dist: str or callable. custom distance measure for k-means. if a\n    string, \"cosine\", \"euclidean\", \"mahalanobis\", or any other distance\n    functions defined in scipy.spatial.distance can be used\n  max_iter: the maximum number of iterations for the custom k-means</p>\n\n<p>Returns:\n  labels: predicted clustering labels of all samples</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">spectral_embeddings</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">n_clusters</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">custom_dist</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">Callable</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">max_iter</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "spectralcluster.custom_distance_kmeans.CustomKMeans", "modulename": "spectralcluster.custom_distance_kmeans", "qualname": "CustomKMeans", "kind": "class", "doc": "<p>Class CustomKMeans performs KMeans clustering.</p>\n"}, {"fullname": "spectralcluster.custom_distance_kmeans.CustomKMeans.__init__", "modulename": "spectralcluster.custom_distance_kmeans", "qualname": "CustomKMeans.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">n_clusters</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">centroids</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">max_iter</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">10</span>,</span><span class=\"param\">\t<span class=\"n\">tol</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.001</span>,</span><span class=\"param\">\t<span class=\"n\">custom_dist</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">Callable</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;cosine&#39;</span></span>)</span>"}, {"fullname": "spectralcluster.custom_distance_kmeans.CustomKMeans.n_clusters", "modulename": "spectralcluster.custom_distance_kmeans", "qualname": "CustomKMeans.n_clusters", "kind": "variable", "doc": "<p></p>\n", "annotation": ": Optional[int]", "default_value": "None"}, {"fullname": "spectralcluster.custom_distance_kmeans.CustomKMeans.centroids", "modulename": "spectralcluster.custom_distance_kmeans", "qualname": "CustomKMeans.centroids", "kind": "variable", "doc": "<p></p>\n", "annotation": ": Optional[numpy.ndarray]", "default_value": "None"}, {"fullname": "spectralcluster.custom_distance_kmeans.CustomKMeans.max_iter", "modulename": "spectralcluster.custom_distance_kmeans", "qualname": "CustomKMeans.max_iter", "kind": "variable", "doc": "<p></p>\n", "annotation": ": int", "default_value": "10"}, {"fullname": "spectralcluster.custom_distance_kmeans.CustomKMeans.tol", "modulename": "spectralcluster.custom_distance_kmeans", "qualname": "CustomKMeans.tol", "kind": "variable", "doc": "<p></p>\n", "annotation": ": float", "default_value": "0.001"}, {"fullname": "spectralcluster.custom_distance_kmeans.CustomKMeans.custom_dist", "modulename": "spectralcluster.custom_distance_kmeans", "qualname": "CustomKMeans.custom_dist", "kind": "variable", "doc": "<p></p>\n", "annotation": ": Union[str, Callable]", "default_value": "&#x27;cosine&#x27;"}, {"fullname": "spectralcluster.custom_distance_kmeans.CustomKMeans.predict", "modulename": "spectralcluster.custom_distance_kmeans", "qualname": "CustomKMeans.predict", "kind": "function", "doc": "<p>Performs the clustering.</p>\n\n<p>Args:\n  embeddings: the input observations to cluster</p>\n\n<p>Returns:\n  labels: predicted clustering labels of all samples</p>\n\n<p>Raises:\n  ValueError: if input observations have wrong shape</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">embeddings</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "spectralcluster.fallback_clusterer", "modulename": "spectralcluster.fallback_clusterer", "kind": "module", "doc": "<p>In some cases, we use a fallback clusterer instead of spectral.</p>\n\n<p>Spectral clustering exploits the global structure of the data. But there are\ncases where spectral clustering does not work as well as some other simpler\nclustering methods, such as when the number of embeddings is too small.</p>\n\n<p>See this paper for more details:\nQuan Wang, Yiling Huang, Han Lu, Guanlong Zhao, Ignacio Lopez Moreno,\n\"Highly Efficient Real-Time Streaming and Fully On-Device Speaker Diarization\nwith Multi-Stage Clustering\", arXiv:2210.13690.\n<a href=\"https://arxiv.org/abs/2210.13690\">https://arxiv.org/abs/2210.13690</a></p>\n"}, {"fullname": "spectralcluster.fallback_clusterer.SingleClusterCondition", "modulename": "spectralcluster.fallback_clusterer", "qualname": "SingleClusterCondition", "kind": "class", "doc": "<p>Which condition do we use for deciding single-vs-multi cluster(s).</p>\n", "bases": "enum.Enum"}, {"fullname": "spectralcluster.fallback_clusterer.SingleClusterCondition.AffinityGmmBic", "modulename": "spectralcluster.fallback_clusterer", "qualname": "SingleClusterCondition.AffinityGmmBic", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;SingleClusterCondition.AffinityGmmBic: 1&gt;"}, {"fullname": "spectralcluster.fallback_clusterer.SingleClusterCondition.AllAffinity", "modulename": "spectralcluster.fallback_clusterer", "qualname": "SingleClusterCondition.AllAffinity", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;SingleClusterCondition.AllAffinity: 2&gt;"}, {"fullname": "spectralcluster.fallback_clusterer.SingleClusterCondition.NeighborAffinity", "modulename": "spectralcluster.fallback_clusterer", "qualname": "SingleClusterCondition.NeighborAffinity", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;SingleClusterCondition.NeighborAffinity: 3&gt;"}, {"fullname": "spectralcluster.fallback_clusterer.SingleClusterCondition.AffinityStd", "modulename": "spectralcluster.fallback_clusterer", "qualname": "SingleClusterCondition.AffinityStd", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;SingleClusterCondition.AffinityStd: 4&gt;"}, {"fullname": "spectralcluster.fallback_clusterer.SingleClusterCondition.FallbackClusterer", "modulename": "spectralcluster.fallback_clusterer", "qualname": "SingleClusterCondition.FallbackClusterer", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;SingleClusterCondition.FallbackClusterer: 5&gt;"}, {"fullname": "spectralcluster.fallback_clusterer.FallbackClustererType", "modulename": "spectralcluster.fallback_clusterer", "qualname": "FallbackClustererType", "kind": "class", "doc": "<p>Which fallback clusterer to use.</p>\n", "bases": "enum.Enum"}, {"fullname": "spectralcluster.fallback_clusterer.FallbackClustererType.Agglomerative", "modulename": "spectralcluster.fallback_clusterer", "qualname": "FallbackClustererType.Agglomerative", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;FallbackClustererType.Agglomerative: 1&gt;"}, {"fullname": "spectralcluster.fallback_clusterer.FallbackClustererType.Naive", "modulename": "spectralcluster.fallback_clusterer", "qualname": "FallbackClustererType.Naive", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;FallbackClustererType.Naive: 2&gt;"}, {"fullname": "spectralcluster.fallback_clusterer.FallbackOptions", "modulename": "spectralcluster.fallback_clusterer", "qualname": "FallbackOptions", "kind": "class", "doc": "<p>Options for fallback options.</p>\n"}, {"fullname": "spectralcluster.fallback_clusterer.FallbackOptions.__init__", "modulename": "spectralcluster.fallback_clusterer", "qualname": "FallbackOptions.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">spectral_min_embeddings</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">single_cluster_condition</span><span class=\"p\">:</span> <span class=\"n\">spectralcluster</span><span class=\"o\">.</span><span class=\"n\">fallback_clusterer</span><span class=\"o\">.</span><span class=\"n\">SingleClusterCondition</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">SingleClusterCondition</span><span class=\"o\">.</span><span class=\"n\">AffinityGmmBic</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">single_cluster_affinity_threshold</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.75</span>,</span><span class=\"param\">\t<span class=\"n\">single_cluster_affinity_diagonal_offset</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">fallback_clusterer_type</span><span class=\"p\">:</span> <span class=\"n\">spectralcluster</span><span class=\"o\">.</span><span class=\"n\">fallback_clusterer</span><span class=\"o\">.</span><span class=\"n\">FallbackClustererType</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">FallbackClustererType</span><span class=\"o\">.</span><span class=\"n\">Naive</span><span class=\"p\">:</span> <span class=\"mi\">2</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">agglomerative_threshold</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.5</span>,</span><span class=\"param\">\t<span class=\"n\">naive_threshold</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.5</span>,</span><span class=\"param\">\t<span class=\"n\">naive_adaptation_threshold</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span>)</span>"}, {"fullname": "spectralcluster.fallback_clusterer.FallbackOptions.spectral_min_embeddings", "modulename": "spectralcluster.fallback_clusterer", "qualname": "FallbackOptions.spectral_min_embeddings", "kind": "variable", "doc": "<p></p>\n", "annotation": ": int", "default_value": "1"}, {"fullname": "spectralcluster.fallback_clusterer.FallbackOptions.single_cluster_condition", "modulename": "spectralcluster.fallback_clusterer", "qualname": "FallbackOptions.single_cluster_condition", "kind": "variable", "doc": "<p></p>\n", "annotation": ": spectralcluster.fallback_clusterer.SingleClusterCondition", "default_value": "&lt;SingleClusterCondition.AffinityGmmBic: 1&gt;"}, {"fullname": "spectralcluster.fallback_clusterer.FallbackOptions.single_cluster_affinity_threshold", "modulename": "spectralcluster.fallback_clusterer", "qualname": "FallbackOptions.single_cluster_affinity_threshold", "kind": "variable", "doc": "<p></p>\n", "annotation": ": float", "default_value": "0.75"}, {"fullname": "spectralcluster.fallback_clusterer.FallbackOptions.single_cluster_affinity_diagonal_offset", "modulename": "spectralcluster.fallback_clusterer", "qualname": "FallbackOptions.single_cluster_affinity_diagonal_offset", "kind": "variable", "doc": "<p></p>\n", "annotation": ": int", "default_value": "1"}, {"fullname": "spectralcluster.fallback_clusterer.FallbackOptions.fallback_clusterer_type", "modulename": "spectralcluster.fallback_clusterer", "qualname": "FallbackOptions.fallback_clusterer_type", "kind": "variable", "doc": "<p></p>\n", "annotation": ": spectralcluster.fallback_clusterer.FallbackClustererType", "default_value": "&lt;FallbackClustererType.Naive: 2&gt;"}, {"fullname": "spectralcluster.fallback_clusterer.FallbackOptions.agglomerative_threshold", "modulename": "spectralcluster.fallback_clusterer", "qualname": "FallbackOptions.agglomerative_threshold", "kind": "variable", "doc": "<p></p>\n", "annotation": ": float", "default_value": "0.5"}, {"fullname": "spectralcluster.fallback_clusterer.FallbackOptions.naive_threshold", "modulename": "spectralcluster.fallback_clusterer", "qualname": "FallbackOptions.naive_threshold", "kind": "variable", "doc": "<p></p>\n", "annotation": ": float", "default_value": "0.5"}, {"fullname": "spectralcluster.fallback_clusterer.FallbackOptions.naive_adaptation_threshold", "modulename": "spectralcluster.fallback_clusterer", "qualname": "FallbackOptions.naive_adaptation_threshold", "kind": "variable", "doc": "<p></p>\n", "annotation": ": Optional[float]", "default_value": "None"}, {"fullname": "spectralcluster.fallback_clusterer.FallbackClusterer", "modulename": "spectralcluster.fallback_clusterer", "qualname": "FallbackClusterer", "kind": "class", "doc": "<p>Fallback clusterer.</p>\n\n<p>The fallback clusterer is introduced in the multi-stage clustering paper\n(https://arxiv.org/abs/2210.13690). So far we simply use\nAgglomerativeClustering.</p>\n"}, {"fullname": "spectralcluster.fallback_clusterer.FallbackClusterer.__init__", "modulename": "spectralcluster.fallback_clusterer", "qualname": "FallbackClusterer.__init__", "kind": "function", "doc": "<p>Initilization of the fallback clusterer.</p>\n\n<p>Args:\n  options: an object of FallbackOptions</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">options</span><span class=\"p\">:</span> <span class=\"n\">spectralcluster</span><span class=\"o\">.</span><span class=\"n\">fallback_clusterer</span><span class=\"o\">.</span><span class=\"n\">FallbackOptions</span></span>)</span>"}, {"fullname": "spectralcluster.fallback_clusterer.FallbackClusterer.options", "modulename": "spectralcluster.fallback_clusterer", "qualname": "FallbackClusterer.options", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "spectralcluster.fallback_clusterer.FallbackClusterer.predict", "modulename": "spectralcluster.fallback_clusterer", "qualname": "FallbackClusterer.predict", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">embeddings</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "spectralcluster.fallback_clusterer.check_single_cluster", "modulename": "spectralcluster.fallback_clusterer", "qualname": "check_single_cluster", "kind": "function", "doc": "<p>Check whether this is only a single cluster.</p>\n\n<p>This function is only called when min_clusters==1.</p>\n\n<p>Args:\n  fallback_options: an object of FallbackOptions\n  embeddings: numpy array of shape (n_samples, n_features)\n  affinity: the affinity matrix of shape (n_samples, (n_samples)</p>\n\n<p>Returns:\n  a boolean, where True means there is only a single cluster</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">fallback_options</span><span class=\"p\">:</span> <span class=\"n\">spectralcluster</span><span class=\"o\">.</span><span class=\"n\">fallback_clusterer</span><span class=\"o\">.</span><span class=\"n\">FallbackOptions</span>,</span><span class=\"param\">\t<span class=\"n\">embeddings</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">affinity</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "spectralcluster.laplacian", "modulename": "spectralcluster.laplacian", "kind": "module", "doc": "<p>Laplacian matrix.</p>\n"}, {"fullname": "spectralcluster.laplacian.EPS", "modulename": "spectralcluster.laplacian", "qualname": "EPS", "kind": "variable", "doc": "<p></p>\n", "default_value": "1e-10"}, {"fullname": "spectralcluster.laplacian.LaplacianType", "modulename": "spectralcluster.laplacian", "qualname": "LaplacianType", "kind": "class", "doc": "<p>Different types of Laplacian matrix.</p>\n", "bases": "enum.Enum"}, {"fullname": "spectralcluster.laplacian.LaplacianType.Affinity", "modulename": "spectralcluster.laplacian", "qualname": "LaplacianType.Affinity", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;LaplacianType.Affinity: 1&gt;"}, {"fullname": "spectralcluster.laplacian.LaplacianType.Unnormalized", "modulename": "spectralcluster.laplacian", "qualname": "LaplacianType.Unnormalized", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;LaplacianType.Unnormalized: 2&gt;"}, {"fullname": "spectralcluster.laplacian.LaplacianType.RandomWalk", "modulename": "spectralcluster.laplacian", "qualname": "LaplacianType.RandomWalk", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;LaplacianType.RandomWalk: 3&gt;"}, {"fullname": "spectralcluster.laplacian.LaplacianType.GraphCut", "modulename": "spectralcluster.laplacian", "qualname": "LaplacianType.GraphCut", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;LaplacianType.GraphCut: 4&gt;"}, {"fullname": "spectralcluster.laplacian.compute_laplacian", "modulename": "spectralcluster.laplacian", "qualname": "compute_laplacian", "kind": "function", "doc": "<p>Compute the Laplacian matrix.</p>\n\n<p>Args:\n  affinity: the affinity matrix of input data\n  laplacian_type: a LaplacianType\n  eps: a small value for numerial stability</p>\n\n<p>Returns:\n  the Laplacian matrix</p>\n\n<p>Raises:\n  TypeError: if laplacian_type is not a LaplacianType\n  ValueError: if laplacian_type is not supported</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">affinity</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">laplacian_type</span><span class=\"p\">:</span> <span class=\"n\">spectralcluster</span><span class=\"o\">.</span><span class=\"n\">laplacian</span><span class=\"o\">.</span><span class=\"n\">LaplacianType</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">LaplacianType</span><span class=\"o\">.</span><span class=\"n\">GraphCut</span><span class=\"p\">:</span> <span class=\"mi\">4</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">eps</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">1e-10</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "spectralcluster.multi_stage_clusterer", "modulename": "spectralcluster.multi_stage_clusterer", "kind": "module", "doc": "<p>Implementation of multi-stage clustering.</p>\n\n<p>Multi-stage clustering class is introduced in this paper:</p>\n\n<ul>\n<li>Quan Wang, Yiling Huang, Han Lu, Guanlong Zhao, Ignacio Lopez Moreno,\n\"Highly efficient real-time streaming and fully on-device speaker\ndiarization with multi-stage clustering.\" arXiv preprint\narXiv:2210.13690 (2022).</li>\n</ul>\n"}, {"fullname": "spectralcluster.multi_stage_clusterer.Deflicker", "modulename": "spectralcluster.multi_stage_clusterer", "qualname": "Deflicker", "kind": "class", "doc": "<p>Method to deflicker the streaming output labels.</p>\n", "bases": "enum.Enum"}, {"fullname": "spectralcluster.multi_stage_clusterer.Deflicker.NoDeflicker", "modulename": "spectralcluster.multi_stage_clusterer", "qualname": "Deflicker.NoDeflicker", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;Deflicker.NoDeflicker: 1&gt;"}, {"fullname": "spectralcluster.multi_stage_clusterer.Deflicker.OrderBased", "modulename": "spectralcluster.multi_stage_clusterer", "qualname": "Deflicker.OrderBased", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;Deflicker.OrderBased: 2&gt;"}, {"fullname": "spectralcluster.multi_stage_clusterer.Deflicker.Hungarian", "modulename": "spectralcluster.multi_stage_clusterer", "qualname": "Deflicker.Hungarian", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;Deflicker.Hungarian: 3&gt;"}, {"fullname": "spectralcluster.multi_stage_clusterer.match_labels", "modulename": "spectralcluster.multi_stage_clusterer", "qualname": "match_labels", "kind": "function", "doc": "<p>Match current labels with previous labels using Hungarian algorithm.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">current</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">previous</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "spectralcluster.multi_stage_clusterer.MultiStageClusterer", "modulename": "spectralcluster.multi_stage_clusterer", "qualname": "MultiStageClusterer", "kind": "class", "doc": "<p>Multi-stage clustering class.</p>\n"}, {"fullname": "spectralcluster.multi_stage_clusterer.MultiStageClusterer.__init__", "modulename": "spectralcluster.multi_stage_clusterer", "qualname": "MultiStageClusterer.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">main_clusterer</span><span class=\"p\">:</span> <span class=\"n\">spectralcluster</span><span class=\"o\">.</span><span class=\"n\">spectral_clusterer</span><span class=\"o\">.</span><span class=\"n\">SpectralClusterer</span>,</span><span class=\"param\">\t<span class=\"n\">fallback_threshold</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.5</span>,</span><span class=\"param\">\t<span class=\"n\">L</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">50</span>,</span><span class=\"param\">\t<span class=\"n\">U1</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">100</span>,</span><span class=\"param\">\t<span class=\"n\">U2</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">600</span>,</span><span class=\"param\">\t<span class=\"n\">deflicker</span><span class=\"p\">:</span> <span class=\"n\">spectralcluster</span><span class=\"o\">.</span><span class=\"n\">multi_stage_clusterer</span><span class=\"o\">.</span><span class=\"n\">Deflicker</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">Deflicker</span><span class=\"o\">.</span><span class=\"n\">NoDeflicker</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"o\">&gt;</span></span>)</span>"}, {"fullname": "spectralcluster.multi_stage_clusterer.MultiStageClusterer.deflicker", "modulename": "spectralcluster.multi_stage_clusterer", "qualname": "MultiStageClusterer.deflicker", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "spectralcluster.multi_stage_clusterer.MultiStageClusterer.main", "modulename": "spectralcluster.multi_stage_clusterer", "qualname": "MultiStageClusterer.main", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "spectralcluster.multi_stage_clusterer.MultiStageClusterer.U1", "modulename": "spectralcluster.multi_stage_clusterer", "qualname": "MultiStageClusterer.U1", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "spectralcluster.multi_stage_clusterer.MultiStageClusterer.U2", "modulename": "spectralcluster.multi_stage_clusterer", "qualname": "MultiStageClusterer.U2", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "spectralcluster.multi_stage_clusterer.MultiStageClusterer.pre", "modulename": "spectralcluster.multi_stage_clusterer", "qualname": "MultiStageClusterer.pre", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "spectralcluster.multi_stage_clusterer.MultiStageClusterer.cache", "modulename": "spectralcluster.multi_stage_clusterer", "qualname": "MultiStageClusterer.cache", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "spectralcluster.multi_stage_clusterer.MultiStageClusterer.num_embeddings", "modulename": "spectralcluster.multi_stage_clusterer", "qualname": "MultiStageClusterer.num_embeddings", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "spectralcluster.multi_stage_clusterer.MultiStageClusterer.compression_labels", "modulename": "spectralcluster.multi_stage_clusterer", "qualname": "MultiStageClusterer.compression_labels", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "spectralcluster.multi_stage_clusterer.MultiStageClusterer.previous_output", "modulename": "spectralcluster.multi_stage_clusterer", "qualname": "MultiStageClusterer.previous_output", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "spectralcluster.multi_stage_clusterer.MultiStageClusterer.streaming_predict", "modulename": "spectralcluster.multi_stage_clusterer", "qualname": "MultiStageClusterer.streaming_predict", "kind": "function", "doc": "<p>A streaming prediction function.</p>\n\n<p>Note that this is not a simple online prediction class It not only\npredicts the label of the next input, but also makes corrections to\npreviously predicted labels.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">embedding</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "spectralcluster.naive_clusterer", "modulename": "spectralcluster.naive_clusterer", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "spectralcluster.naive_clusterer.NaiveCentroid", "modulename": "spectralcluster.naive_clusterer", "qualname": "NaiveCentroid", "kind": "class", "doc": "<p>A cluster centroid of the Naive clustering algorithm.</p>\n"}, {"fullname": "spectralcluster.naive_clusterer.NaiveCentroid.__init__", "modulename": "spectralcluster.naive_clusterer", "qualname": "NaiveCentroid.__init__", "kind": "function", "doc": "<p>Create a new centroid.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">embedding</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span>)</span>"}, {"fullname": "spectralcluster.naive_clusterer.NaiveCentroid.embedding", "modulename": "spectralcluster.naive_clusterer", "qualname": "NaiveCentroid.embedding", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "spectralcluster.naive_clusterer.NaiveCentroid.count", "modulename": "spectralcluster.naive_clusterer", "qualname": "NaiveCentroid.count", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "spectralcluster.naive_clusterer.NaiveCentroid.merge", "modulename": "spectralcluster.naive_clusterer", "qualname": "NaiveCentroid.merge", "kind": "function", "doc": "<p>Merge a new embedding into the centroid.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">embedding</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "spectralcluster.naive_clusterer.NaiveCentroid.cosine", "modulename": "spectralcluster.naive_clusterer", "qualname": "NaiveCentroid.cosine", "kind": "function", "doc": "<p>Compute cosine similarity to a new embedding.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">embedding</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "spectralcluster.naive_clusterer.NaiveClusterer", "modulename": "spectralcluster.naive_clusterer", "qualname": "NaiveClusterer", "kind": "class", "doc": "<p>Naive clustering class.</p>\n"}, {"fullname": "spectralcluster.naive_clusterer.NaiveClusterer.__init__", "modulename": "spectralcluster.naive_clusterer", "qualname": "NaiveClusterer.__init__", "kind": "function", "doc": "<p>Initialized the clusterer.</p>\n\n<p>Note that since this is online clustering, fit_predict and predict\nare the same.</p>\n\n<p>Args:\n  threshold: if cosine similarity is larger than this threshold, the\n    embedding will be considered to belong to the cluster\n  adaptation_threshold: if cosine similarity is larger than\n    adaptation_threshold, the embedding will be merged to the cluster.\n    If None, we use threshold as adaptation_threshold</p>\n\n<p>Raises:\n  ValueError: if adaptation_threshold is smaller than threshold</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">threshold</span><span class=\"p\">:</span> <span class=\"nb\">float</span>, </span><span class=\"param\"><span class=\"n\">adaptation_threshold</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span>)</span>"}, {"fullname": "spectralcluster.naive_clusterer.NaiveClusterer.threshold", "modulename": "spectralcluster.naive_clusterer", "qualname": "NaiveClusterer.threshold", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "spectralcluster.naive_clusterer.NaiveClusterer.centroids", "modulename": "spectralcluster.naive_clusterer", "qualname": "NaiveClusterer.centroids", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "spectralcluster.naive_clusterer.NaiveClusterer.reset", "modulename": "spectralcluster.naive_clusterer", "qualname": "NaiveClusterer.reset", "kind": "function", "doc": "<p>Reset the clusterer.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "spectralcluster.naive_clusterer.NaiveClusterer.predict_next", "modulename": "spectralcluster.naive_clusterer", "qualname": "NaiveClusterer.predict_next", "kind": "function", "doc": "<p>Given a new embedding, output its label.</p>\n\n<p>This is used for online clustering.</p>\n\n<p>Args:\n  embedding: numpy array of shape (n_features,)</p>\n\n<p>Returns:\n  label: an integer cluster label</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">embedding</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "spectralcluster.naive_clusterer.NaiveClusterer.predict", "modulename": "spectralcluster.naive_clusterer", "qualname": "NaiveClusterer.predict", "kind": "function", "doc": "<p>Given many embeddings, return all cluster labels.</p>\n\n<p>This is for simulating offline clustering behavior.</p>\n\n<p>Args:\n  embeddings: numpy array of shape (n_samples, n_features)</p>\n\n<p>Returns:\n  labels: numpy array of shape (n_samples,)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">embeddings</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "spectralcluster.naive_clusterer.NaiveClusterer.fit_predict", "modulename": "spectralcluster.naive_clusterer", "qualname": "NaiveClusterer.fit_predict", "kind": "function", "doc": "<p>Same as predict(), since this is an online clusterer.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">embeddings</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "spectralcluster.refinement", "modulename": "spectralcluster.refinement", "kind": "module", "doc": "<p>Affinity matrix refinemnet operations.</p>\n"}, {"fullname": "spectralcluster.refinement.RefinementName", "modulename": "spectralcluster.refinement", "qualname": "RefinementName", "kind": "class", "doc": "<p>The names of the refinement operations.</p>\n", "bases": "enum.Enum"}, {"fullname": "spectralcluster.refinement.RefinementName.CropDiagonal", "modulename": "spectralcluster.refinement", "qualname": "RefinementName.CropDiagonal", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;RefinementName.CropDiagonal: 1&gt;"}, {"fullname": "spectralcluster.refinement.RefinementName.GaussianBlur", "modulename": "spectralcluster.refinement", "qualname": "RefinementName.GaussianBlur", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;RefinementName.GaussianBlur: 2&gt;"}, {"fullname": "spectralcluster.refinement.RefinementName.RowWiseThreshold", "modulename": "spectralcluster.refinement", "qualname": "RefinementName.RowWiseThreshold", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;RefinementName.RowWiseThreshold: 3&gt;"}, {"fullname": "spectralcluster.refinement.RefinementName.Symmetrize", "modulename": "spectralcluster.refinement", "qualname": "RefinementName.Symmetrize", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;RefinementName.Symmetrize: 4&gt;"}, {"fullname": "spectralcluster.refinement.RefinementName.Diffuse", "modulename": "spectralcluster.refinement", "qualname": "RefinementName.Diffuse", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;RefinementName.Diffuse: 5&gt;"}, {"fullname": "spectralcluster.refinement.RefinementName.RowWiseNormalize", "modulename": "spectralcluster.refinement", "qualname": "RefinementName.RowWiseNormalize", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;RefinementName.RowWiseNormalize: 6&gt;"}, {"fullname": "spectralcluster.refinement.ThresholdType", "modulename": "spectralcluster.refinement", "qualname": "ThresholdType", "kind": "class", "doc": "<p>Different types of thresholding.</p>\n", "bases": "enum.Enum"}, {"fullname": "spectralcluster.refinement.ThresholdType.RowMax", "modulename": "spectralcluster.refinement", "qualname": "ThresholdType.RowMax", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;ThresholdType.RowMax: 1&gt;"}, {"fullname": "spectralcluster.refinement.ThresholdType.Percentile", "modulename": "spectralcluster.refinement", "qualname": "ThresholdType.Percentile", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;ThresholdType.Percentile: 2&gt;"}, {"fullname": "spectralcluster.refinement.SymmetrizeType", "modulename": "spectralcluster.refinement", "qualname": "SymmetrizeType", "kind": "class", "doc": "<p>Different types of symmetrization operation.</p>\n", "bases": "enum.Enum"}, {"fullname": "spectralcluster.refinement.SymmetrizeType.Max", "modulename": "spectralcluster.refinement", "qualname": "SymmetrizeType.Max", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;SymmetrizeType.Max: 1&gt;"}, {"fullname": "spectralcluster.refinement.SymmetrizeType.Average", "modulename": "spectralcluster.refinement", "qualname": "SymmetrizeType.Average", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;SymmetrizeType.Average: 2&gt;"}, {"fullname": "spectralcluster.refinement.AffinityRefinementOperation", "modulename": "spectralcluster.refinement", "qualname": "AffinityRefinementOperation", "kind": "class", "doc": "<p>Refinement of the affinity matrix.</p>\n"}, {"fullname": "spectralcluster.refinement.AffinityRefinementOperation.check_input", "modulename": "spectralcluster.refinement", "qualname": "AffinityRefinementOperation.check_input", "kind": "function", "doc": "<p>Check the input to the refine() method.</p>\n\n<p>Args:\n  affinity: the input affinity matrix.</p>\n\n<p>Raises:\n  TypeError: if affinity has wrong type\n  ValueError: if affinity has wrong shape, etc.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">affinity</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "spectralcluster.refinement.AffinityRefinementOperation.refine", "modulename": "spectralcluster.refinement", "qualname": "AffinityRefinementOperation.refine", "kind": "function", "doc": "<p>An abstract method to perform the refinement operation.</p>\n\n<p>Args:\n    affinity: the affinity matrix, of size (n_samples, n_samples)</p>\n\n<p>Returns:\n    a matrix of the same size as affinity</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">affinity</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "spectralcluster.refinement.RefinementOptions", "modulename": "spectralcluster.refinement", "qualname": "RefinementOptions", "kind": "class", "doc": "<p>Refinement options for the affinity matrix.</p>\n"}, {"fullname": "spectralcluster.refinement.RefinementOptions.__init__", "modulename": "spectralcluster.refinement", "qualname": "RefinementOptions.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">gaussian_blur_sigma</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">p_percentile</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.95</span>,</span><span class=\"param\">\t<span class=\"n\">thresholding_soft_multiplier</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.01</span>,</span><span class=\"param\">\t<span class=\"n\">thresholding_type</span><span class=\"p\">:</span> <span class=\"n\">spectralcluster</span><span class=\"o\">.</span><span class=\"n\">refinement</span><span class=\"o\">.</span><span class=\"n\">ThresholdType</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">ThresholdType</span><span class=\"o\">.</span><span class=\"n\">RowMax</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">thresholding_with_binarization</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">thresholding_preserve_diagonal</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">symmetrize_type</span><span class=\"p\">:</span> <span class=\"n\">spectralcluster</span><span class=\"o\">.</span><span class=\"n\">refinement</span><span class=\"o\">.</span><span class=\"n\">SymmetrizeType</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">SymmetrizeType</span><span class=\"o\">.</span><span class=\"n\">Max</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">refinement_sequence</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"n\">spectralcluster</span><span class=\"o\">.</span><span class=\"n\">refinement</span><span class=\"o\">.</span><span class=\"n\">RefinementName</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span>)</span>"}, {"fullname": "spectralcluster.refinement.RefinementOptions.gaussian_blur_sigma", "modulename": "spectralcluster.refinement", "qualname": "RefinementOptions.gaussian_blur_sigma", "kind": "variable", "doc": "<p></p>\n", "annotation": ": int", "default_value": "1"}, {"fullname": "spectralcluster.refinement.RefinementOptions.p_percentile", "modulename": "spectralcluster.refinement", "qualname": "RefinementOptions.p_percentile", "kind": "variable", "doc": "<p></p>\n", "annotation": ": float", "default_value": "0.95"}, {"fullname": "spectralcluster.refinement.RefinementOptions.thresholding_soft_multiplier", "modulename": "spectralcluster.refinement", "qualname": "RefinementOptions.thresholding_soft_multiplier", "kind": "variable", "doc": "<p></p>\n", "annotation": ": float", "default_value": "0.01"}, {"fullname": "spectralcluster.refinement.RefinementOptions.thresholding_type", "modulename": "spectralcluster.refinement", "qualname": "RefinementOptions.thresholding_type", "kind": "variable", "doc": "<p></p>\n", "annotation": ": spectralcluster.refinement.ThresholdType", "default_value": "&lt;ThresholdType.RowMax: 1&gt;"}, {"fullname": "spectralcluster.refinement.RefinementOptions.thresholding_with_binarization", "modulename": "spectralcluster.refinement", "qualname": "RefinementOptions.thresholding_with_binarization", "kind": "variable", "doc": "<p></p>\n", "annotation": ": bool", "default_value": "False"}, {"fullname": "spectralcluster.refinement.RefinementOptions.thresholding_preserve_diagonal", "modulename": "spectralcluster.refinement", "qualname": "RefinementOptions.thresholding_preserve_diagonal", "kind": "variable", "doc": "<p></p>\n", "annotation": ": bool", "default_value": "False"}, {"fullname": "spectralcluster.refinement.RefinementOptions.symmetrize_type", "modulename": "spectralcluster.refinement", "qualname": "RefinementOptions.symmetrize_type", "kind": "variable", "doc": "<p></p>\n", "annotation": ": spectralcluster.refinement.SymmetrizeType", "default_value": "&lt;SymmetrizeType.Max: 1&gt;"}, {"fullname": "spectralcluster.refinement.RefinementOptions.refinement_sequence", "modulename": "spectralcluster.refinement", "qualname": "RefinementOptions.refinement_sequence", "kind": "variable", "doc": "<p></p>\n", "annotation": ": Optional[Sequence[spectralcluster.refinement.RefinementName]]", "default_value": "None"}, {"fullname": "spectralcluster.refinement.RefinementOptions.get_refinement_operator", "modulename": "spectralcluster.refinement", "qualname": "RefinementOptions.get_refinement_operator", "kind": "function", "doc": "<p>Get the refinement operator for the affinity matrix.</p>\n\n<p>Args:\n  name: a RefinementName</p>\n\n<p>Returns:\n  object of the operator</p>\n\n<p>Raises:\n  TypeError: if name is not a RefinementName\n  ValueError: if name is an unknown refinement operation</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">name</span><span class=\"p\">:</span> <span class=\"n\">spectralcluster</span><span class=\"o\">.</span><span class=\"n\">refinement</span><span class=\"o\">.</span><span class=\"n\">RefinementName</span></span><span class=\"return-annotation\">) -> <span class=\"n\">spectralcluster</span><span class=\"o\">.</span><span class=\"n\">refinement</span><span class=\"o\">.</span><span class=\"n\">AffinityRefinementOperation</span>:</span></span>", "funcdef": "def"}, {"fullname": "spectralcluster.refinement.CropDiagonal", "modulename": "spectralcluster.refinement", "qualname": "CropDiagonal", "kind": "class", "doc": "<p>Crop the diagonal.</p>\n\n<p>Replace diagonal element by the max non-diagonal value of row.\nAfter this operation, the matrix has similar properties to a standard\nLaplacian matrix. This also helps to avoid the bias during Gaussian blur and\nnormalization.</p>\n", "bases": "AffinityRefinementOperation"}, {"fullname": "spectralcluster.refinement.CropDiagonal.refine", "modulename": "spectralcluster.refinement", "qualname": "CropDiagonal.refine", "kind": "function", "doc": "<p>An abstract method to perform the refinement operation.</p>\n\n<p>Args:\n    affinity: the affinity matrix, of size (n_samples, n_samples)</p>\n\n<p>Returns:\n    a matrix of the same size as affinity</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">affinity</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "spectralcluster.refinement.GaussianBlur", "modulename": "spectralcluster.refinement", "qualname": "GaussianBlur", "kind": "class", "doc": "<p>Apply Gaussian blur.</p>\n", "bases": "AffinityRefinementOperation"}, {"fullname": "spectralcluster.refinement.GaussianBlur.__init__", "modulename": "spectralcluster.refinement", "qualname": "GaussianBlur.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">sigma</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span></span>)</span>"}, {"fullname": "spectralcluster.refinement.GaussianBlur.sigma", "modulename": "spectralcluster.refinement", "qualname": "GaussianBlur.sigma", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "spectralcluster.refinement.GaussianBlur.refine", "modulename": "spectralcluster.refinement", "qualname": "GaussianBlur.refine", "kind": "function", "doc": "<p>An abstract method to perform the refinement operation.</p>\n\n<p>Args:\n    affinity: the affinity matrix, of size (n_samples, n_samples)</p>\n\n<p>Returns:\n    a matrix of the same size as affinity</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">affinity</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "spectralcluster.refinement.RowWiseThreshold", "modulename": "spectralcluster.refinement", "qualname": "RowWiseThreshold", "kind": "class", "doc": "<p>Apply row wise thresholding.</p>\n", "bases": "AffinityRefinementOperation"}, {"fullname": "spectralcluster.refinement.RowWiseThreshold.__init__", "modulename": "spectralcluster.refinement", "qualname": "RowWiseThreshold.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">p_percentile</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.95</span>,</span><span class=\"param\">\t<span class=\"n\">thresholding_soft_multiplier</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.01</span>,</span><span class=\"param\">\t<span class=\"n\">thresholding_type</span><span class=\"p\">:</span> <span class=\"n\">spectralcluster</span><span class=\"o\">.</span><span class=\"n\">refinement</span><span class=\"o\">.</span><span class=\"n\">ThresholdType</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">ThresholdType</span><span class=\"o\">.</span><span class=\"n\">RowMax</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">thresholding_with_binarization</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">thresholding_preserve_diagonal</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span>)</span>"}, {"fullname": "spectralcluster.refinement.RowWiseThreshold.p_percentile", "modulename": "spectralcluster.refinement", "qualname": "RowWiseThreshold.p_percentile", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "spectralcluster.refinement.RowWiseThreshold.multiplier", "modulename": "spectralcluster.refinement", "qualname": "RowWiseThreshold.multiplier", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "spectralcluster.refinement.RowWiseThreshold.thresholding_type", "modulename": "spectralcluster.refinement", "qualname": "RowWiseThreshold.thresholding_type", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "spectralcluster.refinement.RowWiseThreshold.thresholding_with_binarization", "modulename": "spectralcluster.refinement", "qualname": "RowWiseThreshold.thresholding_with_binarization", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "spectralcluster.refinement.RowWiseThreshold.thresholding_preserve_diagonal", "modulename": "spectralcluster.refinement", "qualname": "RowWiseThreshold.thresholding_preserve_diagonal", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "spectralcluster.refinement.RowWiseThreshold.refine", "modulename": "spectralcluster.refinement", "qualname": "RowWiseThreshold.refine", "kind": "function", "doc": "<p>An abstract method to perform the refinement operation.</p>\n\n<p>Args:\n    affinity: the affinity matrix, of size (n_samples, n_samples)</p>\n\n<p>Returns:\n    a matrix of the same size as affinity</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">affinity</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "spectralcluster.refinement.Symmetrize", "modulename": "spectralcluster.refinement", "qualname": "Symmetrize", "kind": "class", "doc": "<p>The Symmetrization operation.</p>\n", "bases": "AffinityRefinementOperation"}, {"fullname": "spectralcluster.refinement.Symmetrize.__init__", "modulename": "spectralcluster.refinement", "qualname": "Symmetrize.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">symmetrize_type</span><span class=\"p\">:</span> <span class=\"n\">spectralcluster</span><span class=\"o\">.</span><span class=\"n\">refinement</span><span class=\"o\">.</span><span class=\"n\">SymmetrizeType</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">SymmetrizeType</span><span class=\"o\">.</span><span class=\"n\">Max</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"o\">&gt;</span></span>)</span>"}, {"fullname": "spectralcluster.refinement.Symmetrize.symmetrize_type", "modulename": "spectralcluster.refinement", "qualname": "Symmetrize.symmetrize_type", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "spectralcluster.refinement.Symmetrize.refine", "modulename": "spectralcluster.refinement", "qualname": "Symmetrize.refine", "kind": "function", "doc": "<p>An abstract method to perform the refinement operation.</p>\n\n<p>Args:\n    affinity: the affinity matrix, of size (n_samples, n_samples)</p>\n\n<p>Returns:\n    a matrix of the same size as affinity</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">affinity</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "spectralcluster.refinement.Diffuse", "modulename": "spectralcluster.refinement", "qualname": "Diffuse", "kind": "class", "doc": "<p>The diffusion operation.</p>\n", "bases": "AffinityRefinementOperation"}, {"fullname": "spectralcluster.refinement.Diffuse.refine", "modulename": "spectralcluster.refinement", "qualname": "Diffuse.refine", "kind": "function", "doc": "<p>An abstract method to perform the refinement operation.</p>\n\n<p>Args:\n    affinity: the affinity matrix, of size (n_samples, n_samples)</p>\n\n<p>Returns:\n    a matrix of the same size as affinity</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">affinity</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "spectralcluster.refinement.RowWiseNormalize", "modulename": "spectralcluster.refinement", "qualname": "RowWiseNormalize", "kind": "class", "doc": "<p>The row wise max normalization operation.</p>\n", "bases": "AffinityRefinementOperation"}, {"fullname": "spectralcluster.refinement.RowWiseNormalize.refine", "modulename": "spectralcluster.refinement", "qualname": "RowWiseNormalize.refine", "kind": "function", "doc": "<p>An abstract method to perform the refinement operation.</p>\n\n<p>Args:\n    affinity: the affinity matrix, of size (n_samples, n_samples)</p>\n\n<p>Returns:\n    a matrix of the same size as affinity</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">affinity</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "spectralcluster.spectral_clusterer", "modulename": "spectralcluster.spectral_clusterer", "kind": "module", "doc": "<p>A spectral clusterer class to perform clustering.</p>\n"}, {"fullname": "spectralcluster.spectral_clusterer.AutoTune", "modulename": "spectralcluster.spectral_clusterer", "qualname": "AutoTune", "kind": "class", "doc": "<p>AutoTune Class.</p>\n\n<p>This auto-tuning method is implemented based on this paper:\nPark, Tae Jin, et al. \"Auto-tuning spectral clustering for speaker\ndiarization using normalized maximum eigengap.\" IEEE Signal Processing Letter\n2019.</p>\n"}, {"fullname": "spectralcluster.spectral_clusterer.AutoTune.__init__", "modulename": "spectralcluster.spectral_clusterer", "qualname": "AutoTune.__init__", "kind": "function", "doc": "<p>Initialization of the autotune arguments.</p>\n\n<p>Args:\n  p_percentile_min: minimum value of p_percentile\n  p_percentile_max: maximum value of p_percentile\n  init_search_step: initial search step size for auto-tuning\n  search_level: hierarchical search level for auto-tuning\n  proxy: which proxy to minimize for auto-tuning</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">p_percentile_min</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.6</span>,</span><span class=\"param\">\t<span class=\"n\">p_percentile_max</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.95</span>,</span><span class=\"param\">\t<span class=\"n\">init_search_step</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.01</span>,</span><span class=\"param\">\t<span class=\"n\">search_level</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">proxy</span><span class=\"p\">:</span> <span class=\"n\">spectralcluster</span><span class=\"o\">.</span><span class=\"n\">autotune</span><span class=\"o\">.</span><span class=\"n\">AutoTuneProxy</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">AutoTuneProxy</span><span class=\"o\">.</span><span class=\"n\">PercentileSqrtOverNME</span><span class=\"p\">:</span> <span class=\"mi\">2</span><span class=\"o\">&gt;</span></span>)</span>"}, {"fullname": "spectralcluster.spectral_clusterer.AutoTune.p_percentile_min", "modulename": "spectralcluster.spectral_clusterer", "qualname": "AutoTune.p_percentile_min", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "spectralcluster.spectral_clusterer.AutoTune.p_percentile_max", "modulename": "spectralcluster.spectral_clusterer", "qualname": "AutoTune.p_percentile_max", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "spectralcluster.spectral_clusterer.AutoTune.search_step", "modulename": "spectralcluster.spectral_clusterer", "qualname": "AutoTune.search_step", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "spectralcluster.spectral_clusterer.AutoTune.search_level", "modulename": "spectralcluster.spectral_clusterer", "qualname": "AutoTune.search_level", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "spectralcluster.spectral_clusterer.AutoTune.proxy", "modulename": "spectralcluster.spectral_clusterer", "qualname": "AutoTune.proxy", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "spectralcluster.spectral_clusterer.AutoTune.get_percentile_range", "modulename": "spectralcluster.spectral_clusterer", "qualname": "AutoTune.get_percentile_range", "kind": "function", "doc": "<p>Get the current percentile search range.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "spectralcluster.spectral_clusterer.AutoTune.update_percentile_range", "modulename": "spectralcluster.spectral_clusterer", "qualname": "AutoTune.update_percentile_range", "kind": "function", "doc": "<p>Update the percentile search range.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">p_percentile_min</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">p_percentile_max</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">search_step</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "spectralcluster.spectral_clusterer.AutoTune.tune", "modulename": "spectralcluster.spectral_clusterer", "qualname": "AutoTune.tune", "kind": "function", "doc": "<p>Tune the hyper-parameter p_percentile.</p>\n\n<p>Use a proxy ratio of DER to tune the hyper-parameter p_percentile. It also\nperforms some side work to do affinity refinement, eigen decomposition, and\nestimate the number of clusters.</p>\n\n<p>Args:\n  p_percentile_to_ratio: a callable to compute the <code>ratio</code> given a\n    <code>p_percentile</code> value</p>\n\n<p>Returns:\n  eigenvectors: sorted eigenvectors. numpy array of shape\n  (n_samples, n_samples)\n  n_clusters: number of clusters as an integer\n  best_p_percentile: p_percentile value that minimizes the ratio</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">p_percentile_to_ratio</span><span class=\"p\">:</span> <span class=\"n\">Callable</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "spectralcluster.spectral_clusterer.AutoTuneProxy", "modulename": "spectralcluster.spectral_clusterer", "qualname": "AutoTuneProxy", "kind": "class", "doc": "<p>What proxy to use as the auto-tuning target.</p>\n", "bases": "enum.Enum"}, {"fullname": "spectralcluster.spectral_clusterer.AutoTuneProxy.PercentileOverNME", "modulename": "spectralcluster.spectral_clusterer", "qualname": "AutoTuneProxy.PercentileOverNME", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;AutoTuneProxy.PercentileOverNME: 1&gt;"}, {"fullname": "spectralcluster.spectral_clusterer.AutoTuneProxy.PercentileSqrtOverNME", "modulename": "spectralcluster.spectral_clusterer", "qualname": "AutoTuneProxy.PercentileSqrtOverNME", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;AutoTuneProxy.PercentileSqrtOverNME: 2&gt;"}, {"fullname": "spectralcluster.spectral_clusterer.ConstraintName", "modulename": "spectralcluster.spectral_clusterer", "qualname": "ConstraintName", "kind": "class", "doc": "<p>The names of constrained operations.</p>\n", "bases": "enum.Enum"}, {"fullname": "spectralcluster.spectral_clusterer.ConstraintName.AffinityIntegration", "modulename": "spectralcluster.spectral_clusterer", "qualname": "ConstraintName.AffinityIntegration", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;ConstraintName.AffinityIntegration: 1&gt;"}, {"fullname": "spectralcluster.spectral_clusterer.ConstraintName.ConstraintPropagation", "modulename": "spectralcluster.spectral_clusterer", "qualname": "ConstraintName.ConstraintPropagation", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;ConstraintName.ConstraintPropagation: 2&gt;"}, {"fullname": "spectralcluster.spectral_clusterer.ConstraintOptions", "modulename": "spectralcluster.spectral_clusterer", "qualname": "ConstraintOptions", "kind": "class", "doc": "<p>Constraint options for constrained clustering methods.</p>\n"}, {"fullname": "spectralcluster.spectral_clusterer.ConstraintOptions.__init__", "modulename": "spectralcluster.spectral_clusterer", "qualname": "ConstraintOptions.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">constraint_name</span><span class=\"p\">:</span> <span class=\"n\">spectralcluster</span><span class=\"o\">.</span><span class=\"n\">constraint</span><span class=\"o\">.</span><span class=\"n\">ConstraintName</span>,</span><span class=\"param\">\t<span class=\"n\">apply_before_refinement</span><span class=\"p\">:</span> <span class=\"nb\">bool</span>,</span><span class=\"param\">\t<span class=\"n\">integration_type</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">spectralcluster</span><span class=\"o\">.</span><span class=\"n\">constraint</span><span class=\"o\">.</span><span class=\"n\">IntegrationType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">constraint_propagation_alpha</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.6</span></span>)</span>"}, {"fullname": "spectralcluster.spectral_clusterer.ConstraintOptions.constraint_name", "modulename": "spectralcluster.spectral_clusterer", "qualname": "ConstraintOptions.constraint_name", "kind": "variable", "doc": "<p></p>\n", "annotation": ": spectralcluster.constraint.ConstraintName"}, {"fullname": "spectralcluster.spectral_clusterer.ConstraintOptions.apply_before_refinement", "modulename": "spectralcluster.spectral_clusterer", "qualname": "ConstraintOptions.apply_before_refinement", "kind": "variable", "doc": "<p></p>\n", "annotation": ": bool"}, {"fullname": "spectralcluster.spectral_clusterer.ConstraintOptions.integration_type", "modulename": "spectralcluster.spectral_clusterer", "qualname": "ConstraintOptions.integration_type", "kind": "variable", "doc": "<p></p>\n", "annotation": ": Optional[spectralcluster.constraint.IntegrationType]", "default_value": "None"}, {"fullname": "spectralcluster.spectral_clusterer.ConstraintOptions.constraint_propagation_alpha", "modulename": "spectralcluster.spectral_clusterer", "qualname": "ConstraintOptions.constraint_propagation_alpha", "kind": "variable", "doc": "<p></p>\n", "annotation": ": float", "default_value": "0.6"}, {"fullname": "spectralcluster.spectral_clusterer.FallbackOptions", "modulename": "spectralcluster.spectral_clusterer", "qualname": "FallbackOptions", "kind": "class", "doc": "<p>Options for fallback options.</p>\n"}, {"fullname": "spectralcluster.spectral_clusterer.FallbackOptions.__init__", "modulename": "spectralcluster.spectral_clusterer", "qualname": "FallbackOptions.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">spectral_min_embeddings</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">single_cluster_condition</span><span class=\"p\">:</span> <span class=\"n\">spectralcluster</span><span class=\"o\">.</span><span class=\"n\">fallback_clusterer</span><span class=\"o\">.</span><span class=\"n\">SingleClusterCondition</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">SingleClusterCondition</span><span class=\"o\">.</span><span class=\"n\">AffinityGmmBic</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">single_cluster_affinity_threshold</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.75</span>,</span><span class=\"param\">\t<span class=\"n\">single_cluster_affinity_diagonal_offset</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">fallback_clusterer_type</span><span class=\"p\">:</span> <span class=\"n\">spectralcluster</span><span class=\"o\">.</span><span class=\"n\">fallback_clusterer</span><span class=\"o\">.</span><span class=\"n\">FallbackClustererType</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">FallbackClustererType</span><span class=\"o\">.</span><span class=\"n\">Naive</span><span class=\"p\">:</span> <span class=\"mi\">2</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">agglomerative_threshold</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.5</span>,</span><span class=\"param\">\t<span class=\"n\">naive_threshold</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.5</span>,</span><span class=\"param\">\t<span class=\"n\">naive_adaptation_threshold</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span>)</span>"}, {"fullname": "spectralcluster.spectral_clusterer.FallbackOptions.spectral_min_embeddings", "modulename": "spectralcluster.spectral_clusterer", "qualname": "FallbackOptions.spectral_min_embeddings", "kind": "variable", "doc": "<p></p>\n", "annotation": ": int", "default_value": "1"}, {"fullname": "spectralcluster.spectral_clusterer.FallbackOptions.single_cluster_condition", "modulename": "spectralcluster.spectral_clusterer", "qualname": "FallbackOptions.single_cluster_condition", "kind": "variable", "doc": "<p></p>\n", "annotation": ": spectralcluster.fallback_clusterer.SingleClusterCondition", "default_value": "&lt;SingleClusterCondition.AffinityGmmBic: 1&gt;"}, {"fullname": "spectralcluster.spectral_clusterer.FallbackOptions.single_cluster_affinity_threshold", "modulename": "spectralcluster.spectral_clusterer", "qualname": "FallbackOptions.single_cluster_affinity_threshold", "kind": "variable", "doc": "<p></p>\n", "annotation": ": float", "default_value": "0.75"}, {"fullname": "spectralcluster.spectral_clusterer.FallbackOptions.single_cluster_affinity_diagonal_offset", "modulename": "spectralcluster.spectral_clusterer", "qualname": "FallbackOptions.single_cluster_affinity_diagonal_offset", "kind": "variable", "doc": "<p></p>\n", "annotation": ": int", "default_value": "1"}, {"fullname": "spectralcluster.spectral_clusterer.FallbackOptions.fallback_clusterer_type", "modulename": "spectralcluster.spectral_clusterer", "qualname": "FallbackOptions.fallback_clusterer_type", "kind": "variable", "doc": "<p></p>\n", "annotation": ": spectralcluster.fallback_clusterer.FallbackClustererType", "default_value": "&lt;FallbackClustererType.Naive: 2&gt;"}, {"fullname": "spectralcluster.spectral_clusterer.FallbackOptions.agglomerative_threshold", "modulename": "spectralcluster.spectral_clusterer", "qualname": "FallbackOptions.agglomerative_threshold", "kind": "variable", "doc": "<p></p>\n", "annotation": ": float", "default_value": "0.5"}, {"fullname": "spectralcluster.spectral_clusterer.FallbackOptions.naive_threshold", "modulename": "spectralcluster.spectral_clusterer", "qualname": "FallbackOptions.naive_threshold", "kind": "variable", "doc": "<p></p>\n", "annotation": ": float", "default_value": "0.5"}, {"fullname": "spectralcluster.spectral_clusterer.FallbackOptions.naive_adaptation_threshold", "modulename": "spectralcluster.spectral_clusterer", "qualname": "FallbackOptions.naive_adaptation_threshold", "kind": "variable", "doc": "<p></p>\n", "annotation": ": Optional[float]", "default_value": "None"}, {"fullname": "spectralcluster.spectral_clusterer.LaplacianType", "modulename": "spectralcluster.spectral_clusterer", "qualname": "LaplacianType", "kind": "class", "doc": "<p>Different types of Laplacian matrix.</p>\n", "bases": "enum.Enum"}, {"fullname": "spectralcluster.spectral_clusterer.LaplacianType.Affinity", "modulename": "spectralcluster.spectral_clusterer", "qualname": "LaplacianType.Affinity", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;LaplacianType.Affinity: 1&gt;"}, {"fullname": "spectralcluster.spectral_clusterer.LaplacianType.Unnormalized", "modulename": "spectralcluster.spectral_clusterer", "qualname": "LaplacianType.Unnormalized", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;LaplacianType.Unnormalized: 2&gt;"}, {"fullname": "spectralcluster.spectral_clusterer.LaplacianType.RandomWalk", "modulename": "spectralcluster.spectral_clusterer", "qualname": "LaplacianType.RandomWalk", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;LaplacianType.RandomWalk: 3&gt;"}, {"fullname": "spectralcluster.spectral_clusterer.LaplacianType.GraphCut", "modulename": "spectralcluster.spectral_clusterer", "qualname": "LaplacianType.GraphCut", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;LaplacianType.GraphCut: 4&gt;"}, {"fullname": "spectralcluster.spectral_clusterer.RefinementName", "modulename": "spectralcluster.spectral_clusterer", "qualname": "RefinementName", "kind": "class", "doc": "<p>The names of the refinement operations.</p>\n", "bases": "enum.Enum"}, {"fullname": "spectralcluster.spectral_clusterer.RefinementName.CropDiagonal", "modulename": "spectralcluster.spectral_clusterer", "qualname": "RefinementName.CropDiagonal", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;RefinementName.CropDiagonal: 1&gt;"}, {"fullname": "spectralcluster.spectral_clusterer.RefinementName.GaussianBlur", "modulename": "spectralcluster.spectral_clusterer", "qualname": "RefinementName.GaussianBlur", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;RefinementName.GaussianBlur: 2&gt;"}, {"fullname": "spectralcluster.spectral_clusterer.RefinementName.RowWiseThreshold", "modulename": "spectralcluster.spectral_clusterer", "qualname": "RefinementName.RowWiseThreshold", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;RefinementName.RowWiseThreshold: 3&gt;"}, {"fullname": "spectralcluster.spectral_clusterer.RefinementName.Symmetrize", "modulename": "spectralcluster.spectral_clusterer", "qualname": "RefinementName.Symmetrize", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;RefinementName.Symmetrize: 4&gt;"}, {"fullname": "spectralcluster.spectral_clusterer.RefinementName.Diffuse", "modulename": "spectralcluster.spectral_clusterer", "qualname": "RefinementName.Diffuse", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;RefinementName.Diffuse: 5&gt;"}, {"fullname": "spectralcluster.spectral_clusterer.RefinementName.RowWiseNormalize", "modulename": "spectralcluster.spectral_clusterer", "qualname": "RefinementName.RowWiseNormalize", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;RefinementName.RowWiseNormalize: 6&gt;"}, {"fullname": "spectralcluster.spectral_clusterer.RefinementOptions", "modulename": "spectralcluster.spectral_clusterer", "qualname": "RefinementOptions", "kind": "class", "doc": "<p>Refinement options for the affinity matrix.</p>\n"}, {"fullname": "spectralcluster.spectral_clusterer.RefinementOptions.__init__", "modulename": "spectralcluster.spectral_clusterer", "qualname": "RefinementOptions.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">gaussian_blur_sigma</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">p_percentile</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.95</span>,</span><span class=\"param\">\t<span class=\"n\">thresholding_soft_multiplier</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.01</span>,</span><span class=\"param\">\t<span class=\"n\">thresholding_type</span><span class=\"p\">:</span> <span class=\"n\">spectralcluster</span><span class=\"o\">.</span><span class=\"n\">refinement</span><span class=\"o\">.</span><span class=\"n\">ThresholdType</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">ThresholdType</span><span class=\"o\">.</span><span class=\"n\">RowMax</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">thresholding_with_binarization</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">thresholding_preserve_diagonal</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">symmetrize_type</span><span class=\"p\">:</span> <span class=\"n\">spectralcluster</span><span class=\"o\">.</span><span class=\"n\">refinement</span><span class=\"o\">.</span><span class=\"n\">SymmetrizeType</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">SymmetrizeType</span><span class=\"o\">.</span><span class=\"n\">Max</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">refinement_sequence</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"n\">spectralcluster</span><span class=\"o\">.</span><span class=\"n\">refinement</span><span class=\"o\">.</span><span class=\"n\">RefinementName</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span>)</span>"}, {"fullname": "spectralcluster.spectral_clusterer.RefinementOptions.gaussian_blur_sigma", "modulename": "spectralcluster.spectral_clusterer", "qualname": "RefinementOptions.gaussian_blur_sigma", "kind": "variable", "doc": "<p></p>\n", "annotation": ": int", "default_value": "1"}, {"fullname": "spectralcluster.spectral_clusterer.RefinementOptions.p_percentile", "modulename": "spectralcluster.spectral_clusterer", "qualname": "RefinementOptions.p_percentile", "kind": "variable", "doc": "<p></p>\n", "annotation": ": float", "default_value": "0.95"}, {"fullname": "spectralcluster.spectral_clusterer.RefinementOptions.thresholding_soft_multiplier", "modulename": "spectralcluster.spectral_clusterer", "qualname": "RefinementOptions.thresholding_soft_multiplier", "kind": "variable", "doc": "<p></p>\n", "annotation": ": float", "default_value": "0.01"}, {"fullname": "spectralcluster.spectral_clusterer.RefinementOptions.thresholding_type", "modulename": "spectralcluster.spectral_clusterer", "qualname": "RefinementOptions.thresholding_type", "kind": "variable", "doc": "<p></p>\n", "annotation": ": spectralcluster.refinement.ThresholdType", "default_value": "&lt;ThresholdType.RowMax: 1&gt;"}, {"fullname": "spectralcluster.spectral_clusterer.RefinementOptions.thresholding_with_binarization", "modulename": "spectralcluster.spectral_clusterer", "qualname": "RefinementOptions.thresholding_with_binarization", "kind": "variable", "doc": "<p></p>\n", "annotation": ": bool", "default_value": "False"}, {"fullname": "spectralcluster.spectral_clusterer.RefinementOptions.thresholding_preserve_diagonal", "modulename": "spectralcluster.spectral_clusterer", "qualname": "RefinementOptions.thresholding_preserve_diagonal", "kind": "variable", "doc": "<p></p>\n", "annotation": ": bool", "default_value": "False"}, {"fullname": "spectralcluster.spectral_clusterer.RefinementOptions.symmetrize_type", "modulename": "spectralcluster.spectral_clusterer", "qualname": "RefinementOptions.symmetrize_type", "kind": "variable", "doc": "<p></p>\n", "annotation": ": spectralcluster.refinement.SymmetrizeType", "default_value": "&lt;SymmetrizeType.Max: 1&gt;"}, {"fullname": "spectralcluster.spectral_clusterer.RefinementOptions.refinement_sequence", "modulename": "spectralcluster.spectral_clusterer", "qualname": "RefinementOptions.refinement_sequence", "kind": "variable", "doc": "<p></p>\n", "annotation": ": Optional[Sequence[spectralcluster.refinement.RefinementName]]", "default_value": "None"}, {"fullname": "spectralcluster.spectral_clusterer.RefinementOptions.get_refinement_operator", "modulename": "spectralcluster.spectral_clusterer", "qualname": "RefinementOptions.get_refinement_operator", "kind": "function", "doc": "<p>Get the refinement operator for the affinity matrix.</p>\n\n<p>Args:\n  name: a RefinementName</p>\n\n<p>Returns:\n  object of the operator</p>\n\n<p>Raises:\n  TypeError: if name is not a RefinementName\n  ValueError: if name is an unknown refinement operation</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">name</span><span class=\"p\">:</span> <span class=\"n\">spectralcluster</span><span class=\"o\">.</span><span class=\"n\">refinement</span><span class=\"o\">.</span><span class=\"n\">RefinementName</span></span><span class=\"return-annotation\">) -> <span class=\"n\">spectralcluster</span><span class=\"o\">.</span><span class=\"n\">refinement</span><span class=\"o\">.</span><span class=\"n\">AffinityRefinementOperation</span>:</span></span>", "funcdef": "def"}, {"fullname": "spectralcluster.spectral_clusterer.EigenGapType", "modulename": "spectralcluster.spectral_clusterer", "qualname": "EigenGapType", "kind": "class", "doc": "<p>Different types of the eigengap computation.</p>\n", "bases": "enum.Enum"}, {"fullname": "spectralcluster.spectral_clusterer.EigenGapType.Ratio", "modulename": "spectralcluster.spectral_clusterer", "qualname": "EigenGapType.Ratio", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;EigenGapType.Ratio: 1&gt;"}, {"fullname": "spectralcluster.spectral_clusterer.EigenGapType.NormalizedDiff", "modulename": "spectralcluster.spectral_clusterer", "qualname": "EigenGapType.NormalizedDiff", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;EigenGapType.NormalizedDiff: 2&gt;"}, {"fullname": "spectralcluster.spectral_clusterer.SpectralClusterer", "modulename": "spectralcluster.spectral_clusterer", "qualname": "SpectralClusterer", "kind": "class", "doc": "<p>Spectral clustering class.</p>\n"}, {"fullname": "spectralcluster.spectral_clusterer.SpectralClusterer.__init__", "modulename": "spectralcluster.spectral_clusterer", "qualname": "SpectralClusterer.__init__", "kind": "function", "doc": "<p>Constructor of the clusterer.</p>\n\n<p>Args:\n  min_clusters: minimal number of clusters allowed (only effective if not\n    None)\n  max_clusters: maximal number of clusters allowed (only effective if not\n    None), can be used together with min_clusters to fix the number of\n    clusters\n  refinement_options: a RefinementOptions object that contains refinement\n    arguments for the affinity matrix. If None, we will not refine\n  autotune: an AutoTune object to automatically search p_percentile\n  fallback_options: a FallbackOptions object to indicate when to run\n    fallback clusterer instead of spectral clusterer\n  laplacian_type: a LaplacianType. If None, we do not use a laplacian matrix\n  stop_eigenvalue: when computing the number of clusters using Eigen Gap, we\n    do not look at eigen values smaller than this value\n  row_wise_renorm: if True, perform row-wise re-normalization on the\n    spectral embeddings\n  custom_dist: str or callable. custom distance measure for k-means. If a\n    string, \"cosine\", \"euclidean\", \"mahalanobis\", or any other distance\n    functions defined in scipy.spatial.distance can be used\n  max_iter: the maximum number of iterations for the custom k-means\n  constraint_options: a ConstraintOptions object that contains constraint\n    arguments\n  eigengap_type: the type of the eigengap computation\n  max_spectral_size: the maximal size of input to the spectral clustering\n    algorithm. If this is set, and the actual input size is larger than\n    this value, then we are going to first use hierarchical clustering\n    to reduce the input size to this number. This can significantly reduce\n    the computational cost for steps like Laplacian matrix and eigen\n    decomposition. However, please note that this may degrade the quality\n    of the final clustering results. This corresponds to the U1 value in\n    the multi-stage clustering paper (<a href=\"https://arxiv.org/abs/2210.13690\">https://arxiv.org/abs/2210.13690</a>)\n  affinity_function: a function to compute the affinity matrix from the\n    embeddings. This defaults to (cos(x,y)+1)/2\n  post_eigen_cluster_function: a function to cluster the spectral embeddings\n    after the eigenvalue computations. This function must have the same\n    signature as custom_distance_kmeans.run_kmeans</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">min_clusters</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">max_clusters</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">refinement_options</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">spectralcluster</span><span class=\"o\">.</span><span class=\"n\">refinement</span><span class=\"o\">.</span><span class=\"n\">RefinementOptions</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">autotune</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">spectralcluster</span><span class=\"o\">.</span><span class=\"n\">autotune</span><span class=\"o\">.</span><span class=\"n\">AutoTune</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">fallback_options</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">spectralcluster</span><span class=\"o\">.</span><span class=\"n\">fallback_clusterer</span><span class=\"o\">.</span><span class=\"n\">FallbackOptions</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">laplacian_type</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">spectralcluster</span><span class=\"o\">.</span><span class=\"n\">laplacian</span><span class=\"o\">.</span><span class=\"n\">LaplacianType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">stop_eigenvalue</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.01</span>,</span><span class=\"param\">\t<span class=\"n\">row_wise_renorm</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">custom_dist</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">Callable</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;cosine&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">max_iter</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">300</span>,</span><span class=\"param\">\t<span class=\"n\">constraint_options</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">spectralcluster</span><span class=\"o\">.</span><span class=\"n\">constraint</span><span class=\"o\">.</span><span class=\"n\">ConstraintOptions</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">eigengap_type</span><span class=\"p\">:</span> <span class=\"n\">spectralcluster</span><span class=\"o\">.</span><span class=\"n\">utils</span><span class=\"o\">.</span><span class=\"n\">EigenGapType</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">EigenGapType</span><span class=\"o\">.</span><span class=\"n\">Ratio</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">max_spectral_size</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">affinity_function</span><span class=\"p\">:</span> <span class=\"n\">Callable</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">function</span> <span class=\"n\">compute_affinity_matrix</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">post_eigen_cluster_function</span><span class=\"p\">:</span> <span class=\"n\">Callable</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">function</span> <span class=\"n\">run_kmeans</span><span class=\"o\">&gt;</span></span>)</span>"}, {"fullname": "spectralcluster.spectral_clusterer.SpectralClusterer.min_clusters", "modulename": "spectralcluster.spectral_clusterer", "qualname": "SpectralClusterer.min_clusters", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "spectralcluster.spectral_clusterer.SpectralClusterer.max_clusters", "modulename": "spectralcluster.spectral_clusterer", "qualname": "SpectralClusterer.max_clusters", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "spectralcluster.spectral_clusterer.SpectralClusterer.autotune", "modulename": "spectralcluster.spectral_clusterer", "qualname": "SpectralClusterer.autotune", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "spectralcluster.spectral_clusterer.SpectralClusterer.laplacian_type", "modulename": "spectralcluster.spectral_clusterer", "qualname": "SpectralClusterer.laplacian_type", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "spectralcluster.spectral_clusterer.SpectralClusterer.row_wise_renorm", "modulename": "spectralcluster.spectral_clusterer", "qualname": "SpectralClusterer.row_wise_renorm", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "spectralcluster.spectral_clusterer.SpectralClusterer.stop_eigenvalue", "modulename": "spectralcluster.spectral_clusterer", "qualname": "SpectralClusterer.stop_eigenvalue", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "spectralcluster.spectral_clusterer.SpectralClusterer.custom_dist", "modulename": "spectralcluster.spectral_clusterer", "qualname": "SpectralClusterer.custom_dist", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "spectralcluster.spectral_clusterer.SpectralClusterer.max_iter", "modulename": "spectralcluster.spectral_clusterer", "qualname": "SpectralClusterer.max_iter", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "spectralcluster.spectral_clusterer.SpectralClusterer.constraint_options", "modulename": "spectralcluster.spectral_clusterer", "qualname": "SpectralClusterer.constraint_options", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "spectralcluster.spectral_clusterer.SpectralClusterer.eigengap_type", "modulename": "spectralcluster.spectral_clusterer", "qualname": "SpectralClusterer.eigengap_type", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "spectralcluster.spectral_clusterer.SpectralClusterer.max_spectral_size", "modulename": "spectralcluster.spectral_clusterer", "qualname": "SpectralClusterer.max_spectral_size", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "spectralcluster.spectral_clusterer.SpectralClusterer.affinity_function", "modulename": "spectralcluster.spectral_clusterer", "qualname": "SpectralClusterer.affinity_function", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "spectralcluster.spectral_clusterer.SpectralClusterer.post_eigen_cluster_function", "modulename": "spectralcluster.spectral_clusterer", "qualname": "SpectralClusterer.post_eigen_cluster_function", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "spectralcluster.spectral_clusterer.SpectralClusterer.predict", "modulename": "spectralcluster.spectral_clusterer", "qualname": "SpectralClusterer.predict", "kind": "function", "doc": "<p>Perform spectral clustering on data embeddings.</p>\n\n<p>The spectral clustering is performed on an affinity matrix.</p>\n\n<p>Args:\n  embeddings: numpy array of shape (n_samples, n_features)\n  constraint_matrix: numpy array of shape (n_samples, n_samples). The\n    constraint matrix with prior information</p>\n\n<p>Returns:\n  labels: numpy array of shape (n_samples,)</p>\n\n<p>Raises:\n  TypeError: if embeddings has wrong type\n  ValueError: if embeddings has wrong shape\n  RuntimeError: if max_spectral_size is set and constraint_matrix is given</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">embeddings</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">constraint_matrix</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "spectralcluster.utils", "modulename": "spectralcluster.utils", "kind": "module", "doc": "<p>Utility functions.</p>\n"}, {"fullname": "spectralcluster.utils.EPS", "modulename": "spectralcluster.utils", "qualname": "EPS", "kind": "variable", "doc": "<p></p>\n", "default_value": "1e-10"}, {"fullname": "spectralcluster.utils.EigenGapType", "modulename": "spectralcluster.utils", "qualname": "EigenGapType", "kind": "class", "doc": "<p>Different types of the eigengap computation.</p>\n", "bases": "enum.Enum"}, {"fullname": "spectralcluster.utils.EigenGapType.Ratio", "modulename": "spectralcluster.utils", "qualname": "EigenGapType.Ratio", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;EigenGapType.Ratio: 1&gt;"}, {"fullname": "spectralcluster.utils.EigenGapType.NormalizedDiff", "modulename": "spectralcluster.utils", "qualname": "EigenGapType.NormalizedDiff", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;EigenGapType.NormalizedDiff: 2&gt;"}, {"fullname": "spectralcluster.utils.compute_affinity_matrix", "modulename": "spectralcluster.utils", "qualname": "compute_affinity_matrix", "kind": "function", "doc": "<p>Compute the affinity matrix from data.</p>\n\n<p>Note that the range of affinity is [0, 1].</p>\n\n<p>Args:\n  embeddings: numpy array of shape (n_samples, n_features)</p>\n\n<p>Returns:\n  affinity: numpy array of shape (n_samples, n_samples)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">embeddings</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "spectralcluster.utils.compute_sorted_eigenvectors", "modulename": "spectralcluster.utils", "qualname": "compute_sorted_eigenvectors", "kind": "function", "doc": "<p>Sort eigenvectors by the real part of eigenvalues.</p>\n\n<p>Args:\n  input_matrix: the matrix to perform eigen analysis with shape (M, M)\n  descend: sort eigenvalues in a descending order. Default is True</p>\n\n<p>Returns:\n  w: sorted eigenvalues of shape (M,)\n  v: sorted eigenvectors, where v[;, i] corresponds to ith largest\n     eigenvalue</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">input_matrix</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">descend</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "spectralcluster.utils.compute_number_of_clusters", "modulename": "spectralcluster.utils", "qualname": "compute_number_of_clusters", "kind": "function", "doc": "<p>Compute number of clusters using EigenGap principle.</p>\n\n<p>Use maximum EigenGap principle to find the number of clusters.</p>\n\n<p>Args:\n  eigenvalues: sorted eigenvalues of the affinity matrix\n  max_clusters: max number of clusters allowed\n  stop_eigenvalue: we do not look at eigen values smaller than this\n  eigengap_type: the type of the eigengap computation\n  descend: sort eigenvalues in a descending order. Default is True\n  eps: a small value for numerial stability</p>\n\n<p>Returns:\n  max_delta_index: number of clusters as an integer\n  max_delta_norm: normalized maximum eigen gap</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">eigenvalues</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">max_clusters</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">stop_eigenvalue</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.01</span>,</span><span class=\"param\">\t<span class=\"n\">eigengap_type</span><span class=\"p\">:</span> <span class=\"n\">spectralcluster</span><span class=\"o\">.</span><span class=\"n\">utils</span><span class=\"o\">.</span><span class=\"n\">EigenGapType</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">EigenGapType</span><span class=\"o\">.</span><span class=\"n\">Ratio</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">descend</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">eps</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">1e-10</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "spectralcluster.utils.enforce_ordered_labels", "modulename": "spectralcluster.utils", "qualname": "enforce_ordered_labels", "kind": "function", "doc": "<p>Transform the label sequence to an ordered form.</p>\n\n<p>This is the same type of label sequence used in the paper \"Discriminative\nneural clustering for speaker diarisation\". This makes the label sequence\npermutation invariant.</p>\n\n<p>Args:\n  labels: an array of integers</p>\n\n<p>Returns:\n  new_labels: an array of integers, where it starts with 0 and smaller\n    labels always appear first</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">labels</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "spectralcluster.utils.get_cluster_centroids", "modulename": "spectralcluster.utils", "qualname": "get_cluster_centroids", "kind": "function", "doc": "<p>Get the centroids of each cluster from the embeddings.</p>\n\n<p>Args:\n  embeddings: numpy array of shape (n_samples, n_features)\n  labels: numpy array of shape (n_samples, )</p>\n\n<p>Returns:\n  numpy array of shape (n_clusters, n_features)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">embeddings</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">labels</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "spectralcluster.utils.chain_labels", "modulename": "spectralcluster.utils", "qualname": "chain_labels", "kind": "function", "doc": "<p>Chain the results with pre-clusterer.</p>\n\n<p>Args:\n  pre_labels: labels of pre-clusterer of shape (n_samples, ); if None,\n    simply return main_labels\n  main_labels: labels of main clusterer of shape (U1, )</p>\n\n<p>Returns:\n  final labels of shape (n_samples, )</p>\n\n<p>ValueError: if main_labels has wrong shape</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">pre_labels</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">main_labels</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();